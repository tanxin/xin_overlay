diff -urN linden/indra/newview/app_settings/settings.xml linden-patched/indra/newview/app_settings/settings.xml
--- linden/indra/newview/app_settings/settings.xml	2009-03-11 18:46:05.000000000 +0100
+++ linden-patched/indra/newview/app_settings/settings.xml	2009-03-16 19:54:28.000000000 +0100
@@ -1,6 +1,50 @@
 <?xml version="1.0" ?>
 <llsd>
 <map>
+    <key>RestrainedLife</key>
+    <map>
+      <key>Comment</key>
+      <string>Toggles the RestrainedLife features (BDSM lockable toys support). Needs a restart of the viewer.</string>
+      <key>Persist</key>
+      <integer>1</integer>
+      <key>Type</key>
+      <string>Boolean</string>
+      <key>Value</key>
+      <integer>0</integer>
+    </map>
+    <key>RestrainedLifeDebug</key>
+    <map>
+      <key>Comment</key>
+      <string>Toggles the RestrainedLife debug mode (displays the commands when in debug mode).</string>
+      <key>Persist</key>
+      <integer>1</integer>
+      <key>Type</key>
+      <string>Boolean</string>
+      <key>Value</key>
+      <integer>0</integer>
+    </map>
+    <key>RestrainedLifeNoSetEnv</key>
+    <map>
+      <key>Comment</key>
+      <string>When TRUE, forbids to set the environment (time of day and Windlight settings) via RestrainedLife. Needs a restart of the viewer.</string>
+      <key>Persist</key>
+      <integer>1</integer>
+      <key>Type</key>
+      <string>Boolean</string>
+      <key>Value</key>
+      <integer>0</integer>
+    </map>
+    <key>RestrainedLifeAllowPutInv</key>
+    <map>
+      <key>Comment</key>
+      <string>When TRUE, allows the RestrainedLife @putinv command.</string>
+      <key>Persist</key>
+      <integer>1</integer>
+      <key>Type</key>
+      <string>Boolean</string>
+      <key>Value</key>
+      <integer>0</integer>
+    </map>
     <key>AFKTimeout</key>
     <map>
       <key>Comment</key>
diff -urN linden/indra/newview/CMakeLists.txt linden-patched/indra/newview/CMakeLists.txt
--- linden/indra/newview/CMakeLists.txt	2009-03-11 18:46:00.000000000 +0100
+++ linden-patched/indra/newview/CMakeLists.txt	2009-03-14 11:56:59.000000000 +0100
@@ -431,6 +431,7 @@
     llxmlrpctransaction.cpp
     noise.cpp
     pipeline.cpp
+    RRInterface.cpp
     )
 
 set(VIEWER_BINARY_NAME "secondlife-bin" CACHE STRING
@@ -834,6 +835,7 @@
     randgauss.h
     VertexCache.h
     VorbisFramework.h
+    RRInterface.h
     )
 
 source_group("CMake Rules" FILES ViewerInstall.cmake)
diff -urN linden/indra/newview/llagent.cpp linden-patched/indra/newview/llagent.cpp
--- linden/indra/newview/llagent.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/llagent.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -132,6 +132,9 @@
 #include "llfollowcam.h"
 
 extern LLMenuBarGL* gMenuBarView;
+//MK
+extern BOOL RRenabled;
+//mk
 
 //drone wandering constants
 const F32 MAX_WANDER_TIME = 20.f;						// seconds
@@ -757,6 +760,12 @@
 // Does this parcel allow you to fly?
 BOOL LLAgent::canFly()
 {
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsFly)
+	{
+		return FALSE;
+	}
+//mk
 	if (isGodlike()) return TRUE;
 
 	LLViewerRegion* regionp = getRegion();
@@ -796,6 +805,12 @@
 
 	if (fly)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsFly)
+		{
+			return;
+		}
+//mk
 		BOOL was_flying = getFlying();
 		if (!canFly() && !was_flying)
 		{
@@ -846,8 +861,11 @@
 		// host_name = regionp->getHost().getHostName();
 
 		std::string ip = regionp->getHost().getString();
-		llinfos << "Moving agent into region: " << regionp->getName()
+		if (!RRenabled || !gAgent.mRRInterface.mContainsShowloc)
+		{
+			llinfos << "Moving agent into region: " << regionp->getName()
 				<< " located at " << ip << llendl;
+		}
 		if (mRegionp)
 		{
 			// We've changed regions, we're now going to change our agent coordinate frame.
@@ -4208,6 +4226,12 @@
 //-----------------------------------------------------------------------------
 void LLAgent::changeCameraToCustomizeAvatar(BOOL avatar_animate, BOOL camera_animate)
 {
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsUnsit)
+	{
+		return;
+	}
+//mk
 	if (LLViewerJoystick::getInstance()->getOverrideCamera())
 	{
 		return;
@@ -5894,6 +5918,15 @@
 // Landmark ID = LLUUID::null means teleport home
 void LLAgent::teleportViaLandmark(const LLUUID& landmark_asset_id)
 {
+//MK
+	LLVOAvatar* avatar = gAgent.getAvatarObject();
+	if (RRenabled && (gAgent.mRRInterface.contains ("tplm") || (gAgent.mRRInterface.mContainsUnsit && avatar && avatar->mIsSitting)))
+	{
+		return;
+	}
+	//// eliminate all restrictions issued from objects the avatar is not wearing
+	//gAgent.mRRInterface.garbageCollector ();
+//mk
 	LLViewerRegion *regionp = getRegion();
 	if(regionp && teleportCore())
 	{
@@ -5909,6 +5942,12 @@
 
 void LLAgent::teleportViaLure(const LLUUID& lure_id, BOOL godlike)
 {
+//MK
+	//// eliminate all restrictions issued from objects the avatar is not wearing
+	//if (RRenabled) {
+	//	gAgent.mRRInterface.garbageCollector ();
+	//}
+//mk
 	LLViewerRegion* regionp = getRegion();
 	if(regionp && teleportCore())
 	{
@@ -5958,6 +5997,15 @@
 
 void LLAgent::teleportViaLocation(const LLVector3d& pos_global)
 {
+//MK
+	LLVOAvatar* avatar = gAgent.getAvatarObject();
+	if (RRenabled && (gAgent.mRRInterface.contains ("tploc") || (gAgent.mRRInterface.mContainsUnsit && avatar && avatar->mIsSitting)))
+	{
+		return;
+	}
+	//// eliminate all restrictions issued from objects the avatar is not wearing
+	//gAgent.mRRInterface.garbageCollector ();
+//mk
 	LLViewerRegion* regionp = getRegion();
 	LLSimInfo* info = LLWorldMap::getInstance()->simInfoFromPosGlobal(pos_global);
 	if(regionp && info)
@@ -7101,7 +7149,16 @@
 void LLAgent::removeWearable( EWearableType type )
 {
 	LLWearable* old_wearable = mWearableEntry[ type ].mWearable;
-
+//MK
+	if (RRenabled)
+	{
+		if (gAgent.mRRInterface.contains ("remoutfit")
+			|| gAgent.mRRInterface.contains ("remoutfit:"+gAgent.mRRInterface.getOutfitLayerAsString (type)))
+		{
+			return;
+		}
+	}
+//mk
 	if ( (gAgent.isTeen())
 		 && (type == WT_UNDERSHIRT || type == WT_UNDERPANTS))
 	{
@@ -7330,9 +7387,31 @@
 {
 	EWearableType type = new_wearable->getType();
 
+//MK
+	if (RRenabled)
+	{
+		if (gAgent.mRRInterface.contains ("addoutfit")
+			|| gAgent.mRRInterface.contains ("addoutfit:"+gAgent.mRRInterface.getOutfitLayerAsString (type)))
+		{
+			return;
+		}
+	}
+//mk
+
 	LLWearable* old_wearable = mWearableEntry[ type ].mWearable;
 	if( old_wearable )
 	{
+//MK
+		if (RRenabled)
+		{
+			if (gAgent.mRRInterface.contains ("remoutfit")
+				|| gAgent.mRRInterface.contains ("remoutfit:"+gAgent.mRRInterface.getOutfitLayerAsString (type)))
+			{
+				// cannot remove this outfit, so cannot replace it either
+				return;
+			}
+		}
+//mk
 		const LLUUID& old_item_id = mWearableEntry[ type ].mItemID;
 		if( (old_wearable->getID() == new_wearable->getID()) &&
 			(old_item_id == new_item->getUUID()) )
diff -urN linden/indra/newview/llagent.h linden-patched/indra/newview/llagent.h
--- linden/indra/newview/llagent.h	2009-03-11 18:46:00.000000000 +0100
+++ linden-patched/indra/newview/llagent.h	2009-03-14 11:56:59.000000000 +0100
@@ -63,6 +63,10 @@
 #include "llviewerinventory.h"
 #include "llagentdata.h"
 
+//MK
+#include "RRInterface.h"
+//mk
+
 // Ventrella
 #include "llfollowcam.h"
 // end Ventrella
@@ -126,6 +130,10 @@
 	// typing state (for both chat and IM).
 	static const F32 TYPING_TIMEOUT_SECS;
 
+//MK
+	RRInterface		mRRInterface;
+//mk
+
 	LLAgent();
 	~LLAgent();
 
diff -urN linden/indra/newview/llappviewer.cpp linden-patched/indra/newview/llappviewer.cpp
--- linden/indra/newview/llappviewer.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llappviewer.cpp	2009-03-15 11:48:53.000000000 +0100
@@ -857,6 +857,9 @@
 	LLTimer debugTime;
 	LLViewerJoystick* joystick(LLViewerJoystick::getInstance());
 	joystick->setNeedsReset(true);
+//MK
+	int garbage_collector_cnt=0;
+//mk
  	
 	// Handle messages
 	while (!LLApp::isExiting())
@@ -916,7 +919,41 @@
 					joystick->scanJoystick();
 					gKeyboard->scanKeyboard();
 				}
-
+//MK
+				// Do some RLV maintenance (garbage collector etc)
+				if (LLStartUp::getStartupState() == STATE_STARTED
+					&& !gViewerWindow->getShowProgress())
+				{
+					// if RLV share inventory has not been fetched yet, fetch it now
+					gAgent.mRRInterface.fetchInventory ();
+					
+					// fire all the stored commands that we received while initializing
+					gAgent.mRRInterface.fireCommands ();
+					
+					// fire the garbage collector for orphaned restrictions
+					if (++garbage_collector_cnt >= 500) {
+						gAgent.mRRInterface.garbageCollector ();
+						garbage_collector_cnt = 0;
+					}
+					
+					// Decrease the automatic reattach timer, and reattach the object when it expires
+					if (gAgent.mRRInterface.sTimeBeforeReattaching > 0)
+					{
+						if (--gAgent.mRRInterface.sTimeBeforeReattaching <= 0)
+						{
+							// We must check whether there is an object waiting to be reattached after having been kicked off while locked.
+							// If there is one, let's reattach it here, to its default attach point.
+							if (gAgent.mRRInterface.sAssetToReattach.notNull())
+							{
+								LLUUID tmp_uuid = gAgent.mRRInterface.sAssetToReattach;
+								gAgent.mRRInterface.sAssetToReattach.setNull();
+								llinfos << "Reattaching asset : " << tmp_uuid << llendl;
+								gAgent.mRRInterface.attachObjectByUUID (tmp_uuid, 0);
+							}
+						}
+					}
+				}
+//mk
 				// Update state based on messages, user input, object idle.
 				{
 					pauseMainloopTimeout(); // *TODO: Remove. Messages shouldn't be stalling for 20+ seconds!
@@ -1841,28 +1878,38 @@
     // injection and steal passwords. Phoenix. SL-55321
     if(clp.hasOption("url"))
     {
-        std::string slurl = clp.getOption("url")[0];
-        if (LLURLDispatcher::isSLURLCommand(slurl))
+//MK
+        if (!gSavedSettings.getBOOL("RestrainedLife"))
         {
-	        LLStartUp::sSLURLCommand = slurl;
-        }
-        else
-        {
-	        LLURLSimString::setString(slurl);
+//mk
+            std::string slurl = clp.getOption("url")[0];
+            if (LLURLDispatcher::isSLURLCommand(slurl))
+            {
+                LLStartUp::sSLURLCommand = slurl;
+            }
+            else
+            {
+                LLURLSimString::setString(slurl);
+            }
         }
     }
     else if(clp.hasOption("slurl"))
     {
-        std::string slurl = clp.getOption("slurl")[0];
-        if(LLURLDispatcher::isSLURL(slurl))
+//MK
+        if (!gSavedSettings.getBOOL("RestrainedLife"))
         {
-            if (LLURLDispatcher::isSLURLCommand(slurl))
+//mk
+            std::string slurl = clp.getOption("slurl")[0];
+            if(LLURLDispatcher::isSLURL(slurl))
             {
-	            LLStartUp::sSLURLCommand = slurl;
-            }
-            else
-            {
-	            LLURLSimString::setString(slurl);
+                if (LLURLDispatcher::isSLURLCommand(slurl))
+                {
+                    LLStartUp::sSLURLCommand = slurl;
+                }
+                else
+                {
+                    LLURLSimString::setString(slurl);
+                }
             }
         }
     }
diff -urN linden/indra/newview/llchatbar.cpp linden-patched/indra/newview/llchatbar.cpp
--- linden/indra/newview/llchatbar.cpp	2009-03-11 18:46:05.000000000 +0100
+++ linden-patched/indra/newview/llchatbar.cpp	2009-03-14 12:08:53.000000000 +0100
@@ -29,6 +29,10 @@
  * $/LicenseInfo$
  */
 
+//MK
+#include "linden_common.h"
+//mk
+
 #include "llviewerprecompiledheaders.h"
 
 #include "llchatbar.h"
@@ -67,6 +71,9 @@
 #include "llviewermenu.h"
 #include "lluictrlfactory.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
 
 //
 // Globals
@@ -394,12 +401,33 @@
 			std::string utf8_revised_text;
 			if (0 == channel)
 			{
-				// discard returned "found" boolean
-				gGestureManager.triggerAndReviseString(utf8text, &utf8_revised_text);
+//MK
+////				// discard returned "found" boolean
+////				gGestureManager.triggerAndReviseString(utf8text, &utf8_revised_text);
+				BOOL found_gesture=gGestureManager.triggerAndReviseString(utf8text, &utf8_revised_text);
+
+				if (RRenabled && gAgent.mRRInterface.contains ("sendchat") && !gAgent.mRRInterface.containsSubstr ("redirchat:"))
+				{
+					// user is forbidden to send any chat message on channel 0 except emotes and OOC text
+					utf8_revised_text = gAgent.mRRInterface.crunchEmote (utf8_revised_text, 20);
+					if (found_gesture && utf8_revised_text=="...") utf8_revised_text="";
+				}
+//mk
 			}
 			else
 			{
-				utf8_revised_text = utf8text;
+//MK
+				std::ostringstream stream;
+				stream << "sendchannel:" << channel;
+				if (RRenabled && gAgent.mRRInterface.contains ("sendchannel") && // user prevented from chatting on private channels
+					!gAgent.mRRInterface.contains (stream.str ()))
+				{
+					// and this channel is no exception
+					utf8_revised_text = "";
+				}
+				else
+//mk
+					utf8_revised_text = utf8text;
 			}
 
 			utf8_revised_text = utf8str_trim(utf8_revised_text);
@@ -483,7 +511,10 @@
 
 	if( (length > 0) && (raw_text[0] != '/') )  // forward slash is used for escape (eg. emote) sequences
 	{
-		gAgent.startTyping();
+//MK
+		if (!RRenabled || !gAgent.mRRInterface.containsSubstr ("redirchat:"))
+//mk
+			gAgent.startTyping();
 	}
 	else
 	{
@@ -584,7 +615,29 @@
 	{
 		utf8_text = utf8str_truncate(utf8_text, MAX_STRING - 1);
 	}
-
+//MK
+	if (RRenabled)
+	{
+		// transform the type according to chatshout, chatnormal and chatwhisper restrictions
+		if (type == CHAT_TYPE_WHISPER && gAgent.mRRInterface.contains ("chatwhisper"))
+		{
+			type = CHAT_TYPE_NORMAL;
+		}
+		if (type == CHAT_TYPE_SHOUT && gAgent.mRRInterface.contains ("chatshout"))
+		{
+			type = CHAT_TYPE_NORMAL;
+		}
+		if ((type == CHAT_TYPE_SHOUT || type == CHAT_TYPE_NORMAL)
+			&& gAgent.mRRInterface.contains ("chatnormal"))
+		{
+			type = CHAT_TYPE_WHISPER;
+		}
+		if (gAgent.mRRInterface.containsSubstr ("redirchat:"))
+		{
+			animate = false;
+		}
+	}
+//mk
 	// Don't animate for chats people can't hear (chat to scripts)
 	if (animate && (channel == 0))
 	{
@@ -622,13 +675,69 @@
 
 void send_chat_from_viewer(const std::string& utf8_out_text, EChatType type, S32 channel)
 {
+//MK
+	if (RRenabled && channel == 0 && gAgent.mRRInterface.containsSubstr ("redirchat:")
+		&& utf8_out_text.find ("/me ") != 0 // not an emote
+		&& utf8_out_text.find ("/me's") != 0 // not an emote
+		&& utf8_out_text.find ("((") != 0) // not an OOC text
+	{
+		// Public chat is redirected => for each redirection, send the same message on the target channel
+		RRMAP::iterator it = gAgent.mRRInterface.sSpecialObjectBehaviours.begin ();
+		std::string behav;
+		while (it != gAgent.mRRInterface.sSpecialObjectBehaviours.end()) {
+			behav = it->second;
+			if (behav.find ("redirchat:") == 0)
+			{
+				S32 ch = atoi (behav.substr (10).c_str()); // length of "redirchat:"
+				std::ostringstream stream;
+				stream << "sendchannel:" << ch;
+				if (!gAgent.mRRInterface.contains ("sendchannel") || // user not prevented from chatting on private channels
+					gAgent.mRRInterface.contains (stream.str ())) // or this channel is no exception
+				{
+					if (ch > 0)
+					{
+						LLMessageSystem* msg = gMessageSystem;
+						msg->newMessageFast(_PREHASH_ChatFromViewer);
+						msg->nextBlockFast(_PREHASH_AgentData);
+						msg->addUUIDFast(_PREHASH_AgentID, gAgent.getID());
+						msg->addUUIDFast(_PREHASH_SessionID, gAgent.getSessionID());
+						msg->nextBlockFast(_PREHASH_ChatData);
+						msg->addStringFast(_PREHASH_Message, utf8_out_text);
+						msg->addU8Fast(_PREHASH_Type, type);
+						msg->addS32("Channel", ch);
+						
+						gAgent.sendReliableMessage();
+					}
+				}
+			}
+			it++;
+		}
+
+		LLViewerStats::getInstance()->incStat(LLViewerStats::ST_CHAT_COUNT);
+
+		// We have redirected the chat message, don't send it on the original channel
+		return;
+	}
+
+	std::string crunchedText = utf8_out_text;
+
+	// There is a redirection in order but this particular message is an emote or an OOC text, so we did't
+	// redirect it. However it has not gone through crunchEmote yet, so we need to do this here
+	if (RRenabled && channel == 0 && gAgent.mRRInterface.containsSubstr ("redirchat:"))
+	{
+		crunchedText = gAgent.mRRInterface.crunchEmote(crunchedText, 20);
+	}
+//mk
 	LLMessageSystem* msg = gMessageSystem;
 	msg->newMessageFast(_PREHASH_ChatFromViewer);
 	msg->nextBlockFast(_PREHASH_AgentData);
 	msg->addUUIDFast(_PREHASH_AgentID, gAgent.getID());
 	msg->addUUIDFast(_PREHASH_SessionID, gAgent.getSessionID());
 	msg->nextBlockFast(_PREHASH_ChatData);
-	msg->addStringFast(_PREHASH_Message, utf8_out_text);
+////	msg->addStringFast(_PREHASH_Message, utf8_out_text);
+//MK	
+	msg->addStringFast(_PREHASH_Message, crunchedText);
+//mk
 	msg->addU8Fast(_PREHASH_Type, type);
 	msg->addS32("Channel", channel);
 
@@ -652,18 +761,25 @@
 		}
 		const std::string& trigger = gestures->getSelectedValue().asString();
 
-		// pretend the user chatted the trigger string, to invoke
-		// substitution and logging.
-		std::string text(trigger);
-		std::string revised_text;
-		gGestureManager.triggerAndReviseString(text, &revised_text);
-
-		revised_text = utf8str_trim(revised_text);
-		if (!revised_text.empty())
+//MK
+		if (!RRenabled || !gAgent.mRRInterface.contains ("sendchat"))
 		{
-			// Don't play nodding animation
-			self->sendChatFromViewer(revised_text, CHAT_TYPE_NORMAL, FALSE);
+//mk
+			// pretend the user chatted the trigger string, to invoke
+			// substitution and logging.
+			std::string text(trigger);
+			std::string revised_text;
+			gGestureManager.triggerAndReviseString(text, &revised_text);
+
+			revised_text = utf8str_trim(revised_text);
+			if (!revised_text.empty())
+			{
+				// Don't play nodding animation
+				self->sendChatFromViewer(revised_text, CHAT_TYPE_NORMAL, FALSE);
+			}
+//MK
 		}
+//mk
 	}
 	self->mGestureLabelTimer.start();
 	if (self->mGestureCombo != NULL)
@@ -691,7 +807,14 @@
 		if (tokens.size() < 2) return false;
 		S32 channel = tokens[0].asInteger();
 		std::string mesg = tokens[1].asString();
-		send_chat_from_viewer(mesg, CHAT_TYPE_NORMAL, channel);
+		EChatType type = CHAT_TYPE_NORMAL;
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("chatnormal"))
+		{
+			type = CHAT_TYPE_WHISPER;
+		}
+//mk
+		send_chat_from_viewer(mesg, type, channel);
 		return true;
 	}
 };
diff -urN linden/indra/newview/llfloaterabout.cpp linden-patched/indra/newview/llfloaterabout.cpp
--- linden/indra/newview/llfloaterabout.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/llfloaterabout.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -63,6 +63,9 @@
 extern LLCPUInfo gSysCPU;
 extern LLMemoryInfo gSysMemory;
 extern U32 gPacketsIn;
+//MK
+extern BOOL RRenabled;
+//mk
 
 ///----------------------------------------------------------------------------
 /// Local function declarations, constants, enums, and typedefs
@@ -115,6 +118,12 @@
 				   LL_VERSION_MAJOR, LL_VERSION_MINOR, LL_VERSION_PATCH, LL_VIEWER_BUILD,
 				   __DATE__, __TIME__,
 				   gSavedSettings.getString("VersionChannelName").c_str());
+//MK
+	if (RRenabled)
+	{
+		version += gAgent.mRRInterface.getVersion () + "\n";
+	}
+//mk
 	support_widget->appendColoredText(version, FALSE, FALSE, gColors.getColor("TextFgReadOnlyColor"));
 	support_widget->appendStyledText(LLTrans::getString("ReleaseNotes"), FALSE, FALSE, &viewer_link_style);
 
@@ -135,22 +144,44 @@
 		LLUIString pos_text = getString("you_are_at");
 		pos_text.setArg("[POSITION]",
 						llformat("%.1f, %.1f, %.1f ", pos.mdV[VX], pos.mdV[VY], pos.mdV[VZ]));
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+		{
+			pos_text = "(Position hidden)\n";
+		}
+//mk
 		support.append(pos_text);
 
 		std::string region_text = llformat("in %s located at ",
 										gAgent.getRegion()->getName().c_str());
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+		{
+			region_text = "(Region hidden)\n";
+		}
+//mk
 		support.append(region_text);
 
-		std::string buffer;
-		buffer = gAgent.getRegion()->getHost().getHostName();
-		support.append(buffer);
-		support.append(" (");
-		buffer = gAgent.getRegion()->getHost().getString();
-		support.append(buffer);
-		support.append(")\n");
-		support.append(gLastVersionChannel);
-		support.append("\n");
-
+//MK
+		if (!RRenabled || !gAgent.mRRInterface.mContainsShowloc)
+		{
+//mk
+			std::string buffer;
+			buffer = gAgent.getRegion()->getHost().getHostName();
+			support.append(buffer);
+			support.append(" (");
+			buffer = gAgent.getRegion()->getHost().getString();
+			support.append(buffer);
+			support.append(")\n");
+			support.append(gLastVersionChannel);
+			support.append("\n");
+//MK
+		}
+		else
+		{
+			support.append ("(Server info hidden)\n\n");
+		}
+//mk
 		support_widget->appendColoredText(support, FALSE, FALSE, gColors.getColor("TextFgReadOnlyColor"));
 		support_widget->appendStyledText(LLTrans::getString("ReleaseNotes"), FALSE, FALSE, &server_link_style);
 
diff -urN linden/indra/newview/llfloaterbeacons.cpp linden-patched/indra/newview/llfloaterbeacons.cpp
--- linden/indra/newview/llfloaterbeacons.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/llfloaterbeacons.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -36,7 +36,11 @@
 #include "lluictrlfactory.h"
 #include "llcheckboxctrl.h"
 #include "pipeline.h"
+//MK
+#include "llagent.h"
 
+extern BOOL RRenabled;
+//mk
 
 LLFloaterBeacons::LLFloaterBeacons(const LLSD& seed)
 {
@@ -92,6 +96,23 @@
 	LLCheckBoxCtrl *check = (LLCheckBoxCtrl *)ctrl;
 	std::string name = check->getName();
 	LLFloaterBeacons* view = (LLFloaterBeacons*)data;
+//MK
+	if (RRenabled && gAgent.mRRInterface.contains ("edit"))
+	{
+		LLPipeline::setRenderScriptedBeacons(FALSE);
+		LLPipeline::setRenderScriptedTouchBeacons(FALSE);
+		view->getChild<LLCheckBoxCtrl>("scripted")->setControlValue(LLSD(FALSE));
+		view->getChild<LLCheckBoxCtrl>("touch_only")->setControlValue(LLSD(FALSE));
+		LLPipeline::setRenderPhysicalBeacons(FALSE);
+		LLPipeline::setRenderSoundBeacons(FALSE);
+		LLPipeline::setRenderParticleBeacons(FALSE);
+		LLPipeline::setRenderBeacons(FALSE);
+		LLPipeline::setRenderHighlights(FALSE);
+		view->getChild<LLCheckBoxCtrl>("beacons")->setControlValue(LLSD(FALSE));
+		view->getChild<LLCheckBoxCtrl>("highlights")->setControlValue(LLSD(FALSE));
+		return;
+	}
+//mk
 	if(     name == "touch_only")
 	{
 		LLPipeline::toggleRenderScriptedTouchBeacons(NULL);
diff -urN linden/indra/newview/llfloaterbuyland.cpp linden-patched/indra/newview/llfloaterbuyland.cpp
--- linden/indra/newview/llfloaterbuyland.cpp	2009-03-11 18:46:05.000000000 +0100
+++ linden-patched/indra/newview/llfloaterbuyland.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -34,6 +34,7 @@
 #include "llfloaterbuyland.h"
 
 // viewer includes
+#include "llxmlrpctransaction.h"
 #include "llagent.h"
 #include "llbutton.h"
 #include "llcachename.h"
@@ -61,7 +62,6 @@
 #include "llweb.h"
 #include "llwindow.h"
 #include "llworld.h"
-#include "llxmlrpctransaction.h"
 #include "llviewernetwork.h"
 #include "roles_constants.h"
 
@@ -71,6 +71,9 @@
 	// how long of a pause in typing a currency buy amount before an
 	// esimate is fetched from the server
 
+//MK
+extern BOOL RRenabled;
+//mk
 class LLFloaterBuyLandUI
 :	public LLFloater
 {
@@ -826,6 +829,12 @@
 	{
 		gCacheName->getFullName(parcelp->getOwnerID(), mParcelSellerName);
 	}
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+	{
+		mParcelSellerName = gAgent.mRRInterface.getDummyName (mParcelSellerName);
+	}
+//mk
 }
 
 
diff -urN linden/indra/newview/llfloaterchat.cpp linden-patched/indra/newview/llfloaterchat.cpp
--- linden/indra/newview/llfloaterchat.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llfloaterchat.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -74,6 +74,10 @@
 #include "llweb.h"
 #include "llstylemap.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 // Used for LCD display
 extern void AddNewIMToLCD(const std::string &newLine);
 extern void AddNewChatToLCD(const std::string &newLine);
@@ -205,11 +209,16 @@
 		chat.mFromID != LLUUID::null &&
 		(line.length() > chat.mFromName.length() && line.find(chat.mFromName,0) == 0))
 	{
-		std::string start_line = line.substr(0, chat.mFromName.length() + 1);
-		line = line.substr(chat.mFromName.length() + 1);
-		const LLStyleSP &sourceStyle = LLStyleMap::instance().lookup(chat.mFromID);
-		edit->appendStyledText(start_line, false, prepend_newline, &sourceStyle);
-		prepend_newline = false;
+//MK
+		if (!RRenabled || !gAgent.mRRInterface.mContainsShownames)
+		{
+//mk
+			std::string start_line = line.substr(0, chat.mFromName.length() + 1);
+			line = line.substr(chat.mFromName.length() + 1);
+			const LLStyleSP &sourceStyle = LLStyleMap::instance().lookup(chat.mFromID);
+			edit->appendStyledText(start_line, false, prepend_newline, &sourceStyle);
+			prepend_newline = false;
+		}
 	}
 	edit->appendColoredText(line, false, prepend_newline, color);
 }
@@ -509,7 +518,12 @@
 void LLFloaterChat::onClickToggleActiveSpeakers(void* userdata)
 {
 	LLFloaterChat* self = (LLFloaterChat*)userdata;
-
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+	{
+		if (!self->childIsVisible("active_speakers_panel")) return;
+	}
+//mk
 	self->childSetVisible("active_speakers_panel", !self->childIsVisible("active_speakers_panel"));
 }
 
diff -urN linden/indra/newview/llfloatergodtools.cpp linden-patched/indra/newview/llfloatergodtools.cpp
--- linden/indra/newview/llfloatergodtools.cpp	2009-03-11 18:46:02.000000000 +0100
+++ linden-patched/indra/newview/llfloatergodtools.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -78,6 +78,10 @@
 
 const F32 SECONDS_BETWEEN_UPDATE_REQUESTS = 5.0f;
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 static LLFloaterGodTools* sGodTools = NULL;
 
 //*****************************************************************************
@@ -1349,6 +1353,12 @@
 	{
 		LLViewerRegion* regionp = *iter;
 		std::string name = regionp->getName();
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+		{
+			name = "(Hidden)";
+		}
+//mk
 		if (!name.empty())
 		{
 			list->addSimpleElement(name);
diff -urN linden/indra/newview/llfloaterland.cpp linden-patched/indra/newview/llfloaterland.cpp
--- linden/indra/newview/llfloaterland.cpp	2009-03-11 18:46:05.000000000 +0100
+++ linden-patched/indra/newview/llfloaterland.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -87,6 +87,10 @@
 
 LLHandle<LLFloater> LLPanelLandGeneral::sBuyPassDialogHandle;
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 // Local classes
 class LLParcelSelectionObserver : public LLParcelObserver
 {
@@ -806,6 +810,12 @@
 void LLPanelLandGeneral::onClickBuyLand(void* data)
 {
 	BOOL* for_group = (BOOL*)data;
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		return;
+	}
+//mk
 	LLViewerParcelMgr::getInstance()->startBuyLand(*for_group);
 }
 
diff -urN linden/indra/newview/llfloatermap.cpp linden-patched/indra/newview/llfloatermap.cpp
--- linden/indra/newview/llfloatermap.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/llfloatermap.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -67,6 +67,10 @@
 
 #include "llglheaders.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 //
 // Constants
 //
@@ -214,3 +218,13 @@
 		}
 	}
 }
+
+//MK
+void LLFloaterMap::open()
+{
+    if (RRenabled && gAgent.mRRInterface.contains ("showminimap")) {
+        return;
+    }
+    LLFloater::open();
+}
+//mk
diff -urN linden/indra/newview/llfloatermap.h linden-patched/indra/newview/llfloatermap.h
--- linden/indra/newview/llfloatermap.h	2009-03-11 18:46:00.000000000 +0100
+++ linden-patched/indra/newview/llfloatermap.h	2009-03-14 11:56:59.000000000 +0100
@@ -52,6 +52,9 @@
 	/*virtual*/ void	draw();
 	/*virtual*/ void	onClose(bool app_quitting);
 	/*virtual*/ BOOL	canClose();
+//MK
+    /*virtual*/ void    open();
+//mk
 
 protected:
 	LLNetMap*		mMap;
diff -urN linden/indra/newview/llfloateropenobject.cpp linden-patched/indra/newview/llfloateropenobject.cpp
--- linden/indra/newview/llfloateropenobject.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llfloateropenobject.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -53,6 +53,9 @@
 #include "lluictrlfactory.h"
 #include "llviewerwindow.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
 
 LLFloaterOpenObject* LLFloaterOpenObject::sInstance = NULL;
 
@@ -207,7 +210,13 @@
 void LLFloaterOpenObject::onClickMoveAndWear(void* data)
 {
 	LLFloaterOpenObject* self = (LLFloaterOpenObject*)data;
-	self->moveToInventory(true);
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsDetach) {
+		self->moveToInventory(false);
+	} else {
+		self->moveToInventory(true);
+	}
+//mk
 	self->close();
 }
 
diff -urN linden/indra/newview/llfloaterproperties.cpp linden-patched/indra/newview/llfloaterproperties.cpp
--- linden/indra/newview/llfloaterproperties.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llfloaterproperties.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -58,6 +58,9 @@
 
 #include "lluictrlfactory.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
 
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Class LLPropertiesObserver
@@ -354,6 +357,12 @@
 		else
 		{
 			gCacheName->getFullName(perm.getOwner(), name);
+//MK
+			if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+			{
+				name = gAgent.mRRInterface.getDummyName (name);
+			}
+//mk
 		}
 		childSetEnabled("BtnOwner",TRUE);
 		childSetEnabled("LabelOwnerTitle",TRUE);
diff -urN linden/indra/newview/llfloaterreporter.cpp linden-patched/indra/newview/llfloaterreporter.cpp
--- linden/indra/newview/llfloaterreporter.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llfloaterreporter.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -85,6 +85,10 @@
 
 #include "llassetuploadresponders.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 const U32 INCLUDE_SCREENSHOT  = 0x01 << 0;
 
 //-----------------------------------------------------------------------------
@@ -132,7 +136,17 @@
 	}
 
 	childSetText("abuse_location_edit", gAgent.getSLURL() );
-
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		childSetVisible("abuse_location_edit", false);
+	}
+	if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+	{
+		childSetVisible("owner_name", false);
+		childSetVisible("abuser_name_edit", false);
+	}
+//mk
 	LLButton* pick_btn = getChild<LLButton>("pick_btn");
 	if (pick_btn)
 	{
@@ -299,7 +313,16 @@
 			LLViewerRegion *regionp = objectp->getRegion();
 			if (regionp)
 			{
-				childSetText("sim_field", regionp->getName());
+//MK
+				if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+				{
+					childSetText("sim_field", std::string ("(Region hidden)"));
+				}
+				else
+				{
+//mk
+					childSetText("sim_field", regionp->getName());
+				}
 				LLVector3d global_pos;
 				global_pos.setVec(objectp->getPositionRegion());
 				setPosBox(global_pos);
@@ -994,6 +1017,12 @@
 		mPosition.mV[VX],
 		mPosition.mV[VY],
 		mPosition.mV[VZ]);
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		pos_string = "";
+	}
+//mk
 	childSetText("pos_field", pos_string);
 }
 
diff -urN linden/indra/newview/llfloatersettingsdebug.cpp linden-patched/indra/newview/llfloatersettingsdebug.cpp
--- linden/indra/newview/llfloatersettingsdebug.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llfloatersettingsdebug.cpp	2009-03-14 12:12:07.000000000 +0100
@@ -38,6 +38,11 @@
 #include "llspinctrl.h"
 #include "llcolorswatch.h"
 #include "llviewercontrol.h"
+//MK
+#include "llagent.h"
+
+extern BOOL RRenabled;
+//mk
 
 LLFloaterSettingsDebug* LLFloaterSettingsDebug::sInstance = NULL;
 
@@ -131,7 +136,7 @@
 
 	LLComboBox* settings_combo = floaterp->getChild<LLComboBox>("settings_combo");
 	LLControlVariable* controlp = (LLControlVariable*)settings_combo->getCurrentUserdata();
-
+	
 	LLVector3 vector;
 	LLVector3d vectord;
 	LLRect rect;
@@ -143,33 +148,106 @@
 	switch(controlp->type())
 	{		
 	  case TYPE_U32:
+//MK
+		// If this debug setting can be changed through RLV and a setdebug restriction is active, ignore the change
+		if (RRenabled && gAgent.mRRInterface.contains ("setdebug")
+			&& gAgent.mRRInterface.sAllowedU32.find (","+controlp->getName()+",") != -1)
+		{
+			return;
+		}
+//mk
 		controlp->set(floaterp->childGetValue("val_spinner_1"));
 		break;
 	  case TYPE_S32:
+//MK
+		// If this debug setting can be changed through RLV and a setdebug restriction is active, ignore the change
+		if (RRenabled && gAgent.mRRInterface.contains ("setdebug")
+			&& gAgent.mRRInterface.sAllowedS32.find (","+controlp->getName()+",") != -1)
+		{
+			return;
+		}
+//mk
 		controlp->set(floaterp->childGetValue("val_spinner_1"));
 		break;
 	  case TYPE_F32:
+//MK
+		// If this debug setting can be changed through RLV and a setdebug restriction is active, ignore the change
+		if (RRenabled && gAgent.mRRInterface.contains ("setdebug")
+			&& gAgent.mRRInterface.sAllowedF32.find (","+controlp->getName()+",") != -1)
+		{
+			return;
+		}
+//mk
 		controlp->set(LLSD(floaterp->childGetValue("val_spinner_1").asReal()));
 		break;
 	  case TYPE_BOOLEAN:
+//MK
+		// If this debug setting can be changed through RLV and a setdebug restriction is active, ignore the change
+		if (RRenabled && gAgent.mRRInterface.contains ("setdebug")
+			&& gAgent.mRRInterface.sAllowedBOOLEAN.find (","+controlp->getName()+",") != -1)
+		{
+			return;
+		}
+		// Special case : don't allow changing VertexShaderEnable nor WindLightUseAtmosShaders if setenv is on
+		if (RRenabled && gAgent.mRRInterface.mContainsSetenv)
+		{
+			if (controlp->getName() == "VertexShaderEnable"
+			|| controlp->getName() == "WindLightUseAtmosShaders"
+			) {
+				return;
+			}
+		}
+//mk
 		controlp->set(floaterp->childGetValue("boolean_combo"));
 		break;
 	  case TYPE_STRING:
+//MK
+		// If this debug setting can be changed through RLV and a setdebug restriction is active, ignore the change
+		if (RRenabled && gAgent.mRRInterface.contains ("setdebug")
+			&& gAgent.mRRInterface.sAllowedSTRING.find (","+controlp->getName()+",") != -1)
+		{
+			return;
+		}
+//mk
 		controlp->set(LLSD(floaterp->childGetValue("val_text").asString()));
 		break;
 	  case TYPE_VEC3:
+//MK
+		// If this debug setting can be changed through RLV and a setdebug restriction is active, ignore the change
+		if (RRenabled && gAgent.mRRInterface.contains ("setdebug")
+			&& gAgent.mRRInterface.sAllowedVEC3.find (","+controlp->getName()+",") != -1)
+		{
+			return;
+		}
+//mk
 		vector.mV[VX] = (F32)floaterp->childGetValue("val_spinner_1").asReal();
 		vector.mV[VY] = (F32)floaterp->childGetValue("val_spinner_2").asReal();
 		vector.mV[VZ] = (F32)floaterp->childGetValue("val_spinner_3").asReal();
 		controlp->set(vector.getValue());
 		break;
 	  case TYPE_VEC3D:
+//MK
+		// If this debug setting can be changed through RLV and a setdebug restriction is active, ignore the change
+		if (RRenabled && gAgent.mRRInterface.contains ("setdebug")
+			&& gAgent.mRRInterface.sAllowedVEC3D.find (","+controlp->getName()+",") != -1)
+		{
+			return;
+		}
+//mk
 		vectord.mdV[VX] = floaterp->childGetValue("val_spinner_1").asReal();
 		vectord.mdV[VY] = floaterp->childGetValue("val_spinner_2").asReal();
 		vectord.mdV[VZ] = floaterp->childGetValue("val_spinner_3").asReal();
 		controlp->set(vectord.getValue());
 		break;
 	  case TYPE_RECT:
+//MK
+		// If this debug setting can be changed through RLV and a setdebug restriction is active, ignore the change
+		if (RRenabled && gAgent.mRRInterface.contains ("setdebug")
+			&& gAgent.mRRInterface.sAllowedRECT.find (","+controlp->getName()+",") != -1)
+		{
+			return;
+		}
+//mk
 		rect.mLeft = floaterp->childGetValue("val_spinner_1").asInteger();
 		rect.mRight = floaterp->childGetValue("val_spinner_2").asInteger();
 		rect.mBottom = floaterp->childGetValue("val_spinner_3").asInteger();
@@ -177,11 +255,27 @@
 		controlp->set(rect.getValue());
 		break;
 	  case TYPE_COL4:
+//MK
+		// If this debug setting can be changed through RLV and a setdebug restriction is active, ignore the change
+		if (RRenabled && gAgent.mRRInterface.contains ("setdebug")
+			&& gAgent.mRRInterface.sAllowedCOL4.find (","+controlp->getName()+",") != -1)
+		{
+			return;
+		}
+//mk
 		col3.setValue(floaterp->childGetValue("color_swatch"));
 		col4 = LLColor4(col3, (F32)floaterp->childGetValue("val_spinner_4").asReal());
 		controlp->set(col4.getValue());
 		break;
 	  case TYPE_COL3:
+//MK
+		// If this debug setting can be changed through RLV and a setdebug restriction is active, ignore the change
+		if (RRenabled && gAgent.mRRInterface.contains ("setdebug")
+			&& gAgent.mRRInterface.sAllowedCOL3.find (","+controlp->getName()+",") != -1)
+		{
+			return;
+		}
+//mk
 		controlp->set(floaterp->childGetValue("color_swatch"));
 		//col3.mV[VRED] = (F32)floaterp->childGetValue("val_spinner_1").asC();
 		//col3.mV[VGREEN] = (F32)floaterp->childGetValue("val_spinner_2").asReal();
@@ -189,6 +283,14 @@
 		//controlp->set(col3.getValue());
 		break;
 	  case TYPE_COL4U:
+//MK
+		// If this debug setting can be changed through RLV and a setdebug restriction is active, ignore the change
+		if (RRenabled && gAgent.mRRInterface.contains ("setdebug")
+			&& gAgent.mRRInterface.sAllowedCOL4U.find (","+controlp->getName()+",") != -1)
+		{
+			return;
+		}
+//mk
 		col3.setValue(floaterp->childGetValue("color_swatch"));
 		col4U.setVecScaleClamp(col3);
 		col4U.mV[VALPHA] = floaterp->childGetValue("val_spinner_4").asInteger();
@@ -202,6 +304,13 @@
 // static
 void LLFloaterSettingsDebug::onClickDefault(void* user_data)
 {
+//MK
+	// Don't allow Reset To Default when under @setdebug (that could give funny results)
+	if (RRenabled && gAgent.mRRInterface.contains ("setdebug"))
+	{
+		return;
+	}
+//mk
 	LLFloaterSettingsDebug* floaterp = (LLFloaterSettingsDebug*)user_data;
 	LLComboBox* settings_combo = floaterp->getChild<LLComboBox>("settings_combo");
 	LLControlVariable* controlp = (LLControlVariable*)settings_combo->getCurrentUserdata();
diff -urN linden/indra/newview/llfloatersnapshot.cpp linden-patched/indra/newview/llfloatersnapshot.cpp
--- linden/indra/newview/llfloatersnapshot.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/llfloatersnapshot.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -74,6 +74,10 @@
 #include "llvfile.h"
 #include "llvfs.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 ///----------------------------------------------------------------------------
 /// Local function declarations, constants, enums, and typedefs
 ///----------------------------------------------------------------------------
@@ -949,6 +953,12 @@
 		LLVFile::writeFile(formatted->getData(), formatted->getDataSize(), gVFS, new_asset_id, LLAssetType::AT_TEXTURE);
 		std::string pos_string;
 		gAgent.buildLocationString(pos_string);
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+		{
+			pos_string = "(Region hidden)";
+		}
+//mk
 		std::string who_took_it;
 		gAgent.buildFullname(who_took_it);
 		upload_new_resource(tid,	// tid
@@ -1274,6 +1284,14 @@
 		&& got_bytes
 		&& previewp->getDataSize() > MAX_POSTCARD_DATASIZE ? LLColor4::red : gColors.getColor( "LabelTextColor" ));
 
+//MK
+	if (RRenabled && gAgent.mRRInterface.hasLockedHuds())
+	{
+		floater->childSetValue("hud_check", TRUE);
+		gSavedSettings.setBOOL( "RenderHUDInSnapshot", TRUE );
+	}
+//mk
+
 	switch(shot_type)
 	{
 	  case LLSnapshotLivePreview::SNAPSHOT_POSTCARD:
@@ -1482,6 +1500,12 @@
 {
 	LLCheckBoxCtrl *check = (LLCheckBoxCtrl *)ctrl;
 	gSavedSettings.setBOOL( "RenderHUDInSnapshot", check->get() );
+//MK
+	if (RRenabled && gAgent.mRRInterface.hasLockedHuds())
+	{
+		gSavedSettings.setBOOL( "RenderHUDInSnapshot", TRUE );
+	}
+//mk
 	
 	LLFloaterSnapshot *view = (LLFloaterSnapshot *)data;
 	if (view)
@@ -1986,6 +2010,13 @@
 
 	childSetCommitCallback("hud_check", Impl::onClickHUDCheck, this);
 	childSetValue("hud_check", gSavedSettings.getBOOL("RenderHUDInSnapshot"));
+//MK
+	if (RRenabled && gAgent.mRRInterface.hasLockedHuds())
+	{
+		childSetValue("hud_check", TRUE);
+		gSavedSettings.setBOOL( "RenderHUDInSnapshot", TRUE );
+	}
+//mk
 
 	childSetCommitCallback("keep_open_check", Impl::onClickKeepOpenCheck, this);
 	childSetValue("keep_open_check", !gSavedSettings.getBOOL("CloseSnapshotOnKeep"));
diff -urN linden/indra/newview/llfloaterworldmap.cpp linden-patched/indra/newview/llfloaterworldmap.cpp
--- linden/indra/newview/llfloaterworldmap.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/llfloaterworldmap.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -71,6 +71,10 @@
 
 #include "llglheaders.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 //---------------------------------------------------------------------------
 // Constants
 //---------------------------------------------------------------------------
@@ -280,6 +284,14 @@
 // static
 void LLFloaterWorldMap::show(void*, BOOL center_on_target)
 {
+//MK
+	if (RRenabled && (
+		gAgent.mRRInterface.contains ("showworldmap")
+		|| gAgent.mRRInterface.mContainsShowloc))
+	{
+		return;
+	}
+//mk
 	BOOL was_visible = gFloaterWorldMap->getVisible();
 
 	gFloaterWorldMap->mIsClosing = FALSE;
@@ -1667,3 +1679,16 @@
 
 	onShowTargetBtn(self);
 }
+
+//MK
+void LLFloaterWorldMap::open()
+{
+	if (RRenabled && (
+		gAgent.mRRInterface.contains ("showworldmap")
+		|| gAgent.mRRInterface.mContainsShowloc))
+	{
+		return;
+	}
+	LLFloater::open();
+}
+//mk
diff -urN linden/indra/newview/llfloaterworldmap.h linden-patched/indra/newview/llfloaterworldmap.h
--- linden/indra/newview/llfloaterworldmap.h	2009-03-11 18:46:01.000000000 +0100
+++ linden-patched/indra/newview/llfloaterworldmap.h	2009-03-14 11:56:59.000000000 +0100
@@ -110,6 +110,9 @@
 
 	// teleport to the tracked item, if there is one
 	void			teleport();
+//MK
+    /*virtual*/ void    open();
+//mk
 
 protected:
 	static void		onPanBtn( void* userdata );
diff -urN linden/indra/newview/llgesturemgr.cpp linden-patched/indra/newview/llgesturemgr.cpp
--- linden/indra/newview/llgesturemgr.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llgesturemgr.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -57,6 +57,10 @@
 #include "llvoavatar.h"
 #include "llviewerstats.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 LLGestureManager gGestureManager;
 
 // Longest time, in seconds, to wait for all animations to stop playing
@@ -868,7 +872,13 @@
 			// Don't animate the nodding, as this might not blend with
 			// other playing animations.
 			const BOOL animate = FALSE;
-
+//MK
+			if (RRenabled && gAgent.mRRInterface.contains ("sendchat") 
+				&& chat_text.find ("/me ") != 0 && chat_text.find ("/me'") != 0)
+			{
+				chat_text = gAgent.mRRInterface.crunchEmote (chat_text, 20);
+			}
+//mk
 			gChatBar->sendChatFromViewer(chat_text, CHAT_TYPE_NORMAL, animate);
 			gesture->mCurrentStep++;
 			break;
diff -urN linden/indra/newview/llglsandbox.cpp linden-patched/indra/newview/llglsandbox.cpp
--- linden/indra/newview/llglsandbox.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/llglsandbox.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -68,6 +68,10 @@
 #include "pipeline.h"
 #include "llspatialpartition.h"
  
+//MK
+extern BOOL RRenabled;
+//mk
+
 BOOL LLAgent::setLookAt(ELookAtType target_type, LLViewerObject *object, LLVector3 position)
 {
 	if(object && object->isAttachment())
@@ -230,6 +234,13 @@
 		LLViewerCamera::getInstance()->setFar(new_far);
 		LLViewerCamera::getInstance()->setNear(new_near);
 	}
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsFartouch) {
+		// don't allow select by rectangle while under fartouch
+		LLViewerCamera::getInstance()->setFar(0.0f);
+		LLViewerCamera::getInstance()->setNear(0.0f);
+	}
+//mk
 	LLViewerCamera::getInstance()->setPerspective(FOR_SELECTION, 
 							center_x-width/2, center_y-height/2, width, height, 
 							limit_select_distance);
diff -urN linden/indra/newview/llhoverview.cpp linden-patched/indra/newview/llhoverview.cpp
--- linden/indra/newview/llhoverview.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llhoverview.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -77,6 +77,10 @@
 const char* DEFAULT_DESC = "(No Description)";
 const F32 DELAY_BEFORE_SHOW_TIP = 0.35f;
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 //
 // Local globals
 //
@@ -257,6 +261,16 @@
 			{
 				line.append(LLTrans::getString("TooltipPerson"));
 			}
+//MK
+			if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+			{
+				line.clear();
+				line.append(firstname->getString());
+				line.append(1, ' ');
+				line.append(lastname->getString());
+				line = gAgent.mRRInterface.getDummyName (line);
+			}
+//mk
 			mText.push_back(line);
 		}
 		else
@@ -307,6 +321,12 @@
 						}
 						else if(gCacheName->getFullName(owner, name))
 						{
+//MK
+							if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+							{
+								name = gAgent.mRRInterface.getDummyName (name);
+							}
+//mk
 							line.append(name);
 						}
 						else
diff -urN linden/indra/newview/llhudtext.cpp linden-patched/indra/newview/llhudtext.cpp
--- linden/indra/newview/llhudtext.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llhudtext.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -55,7 +55,11 @@
 #include "llmenugl.h"
 #include "pipeline.h"
 #include <boost/tokenizer.hpp>
+//MK
+#include "llviewerregion.h"
 
+extern BOOL RRenabled;
+//mk
 
 const F32 SPRING_STRENGTH = 0.7f;
 const F32 RESTORATION_SPRING_TIME_CONSTANT = 0.1f;
@@ -571,7 +575,24 @@
 void LLHUDText::setString(const LLWString &wtext)
 {
 	mTextSegments.clear();
-	addLine(wtext, mColor);
+//MK
+	LLWString local_wtext = wtext;
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		std::string str = wstring_to_utf8str(local_wtext, local_wtext.length());
+		str = gAgent.mRRInterface.stringReplace(str, gAgent.mRRInterface.getParcelName(), "(Parcel hidden)");
+		str = gAgent.mRRInterface.stringReplace(str, gAgent.getRegion()->getName(), "(Region hidden)");
+		local_wtext = utf8str_to_wstring(str, str.length());
+	}
+	if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+	{
+		std::string str = wstring_to_utf8str(local_wtext, local_wtext.length());
+		str = gAgent.mRRInterface.getCensoredMessage(str);
+		local_wtext = utf8str_to_wstring(str, str.length());
+	}
+	addLine(local_wtext, mColor);
+////	addLine(wtext, mColor);
+//mk
 }
 
 void LLHUDText::clearString()
diff -urN linden/indra/newview/llimpanel.cpp linden-patched/indra/newview/llimpanel.cpp
--- linden/indra/newview/llimpanel.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llimpanel.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -74,6 +74,10 @@
 #include "llmutelist.h"
 #include "llstylemap.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 //
 // Constants
 //
@@ -1975,6 +1979,17 @@
 	if (mInputEditor)
 	{
 		LLWString text = mInputEditor->getConvertedText();
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("sendim"))
+		{
+			// user is forbidden to send IMs
+			if (!gAgent.mRRInterface.contains ("sendim:"+mOtherParticipantUUID.asString()))
+			{
+				// ... and the receiver is no exception
+				text = utf8str_to_wstring("*** IM blocked by sender's viewer"); // signal both the sender and the receiver
+		}
+	}
+//mk
 		if(!text.empty())
 		{
 			// Truncate and convert to UTF8 for transport
diff -urN linden/indra/newview/llimview.cpp linden-patched/indra/newview/llimview.cpp
--- linden/indra/newview/llimview.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llimview.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -69,6 +69,10 @@
 
 #include "llfirstuse.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 //
 // Globals
 //
@@ -1542,7 +1546,12 @@
 			{
 				return;
 			}
-
+//MK            
+			if (RRenabled && gAgent.mRRInterface.contains ("recvim"))
+			{
+				return;
+			}
+//mk
 			// standard message, not from system
 			std::string saved;
 			if(offline == IM_OFFLINE)
diff -urN linden/indra/newview/llinventorybridge.cpp linden-patched/indra/newview/llinventorybridge.cpp
--- linden/indra/newview/llinventorybridge.cpp	2009-03-11 18:46:02.000000000 +0100
+++ linden-patched/indra/newview/llinventorybridge.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -86,6 +86,10 @@
 #include "llselectmgr.h"
 #include "llfloateropenobject.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 // Helpers
 // bug in busy count inc/dec right now, logic is complex... do we really need it?
 void inc_busy_count()
@@ -1815,10 +1819,11 @@
 	LLIsType is_object( LLAssetType::AT_OBJECT );
 	LLIsType is_gesture( LLAssetType::AT_GESTURE );
 
-	if (mWearables ||
+//MK	
+	if (!RRenabled && (mWearables ||
 		checkFolderForContentsOfType(model, is_wearable)  ||
 		checkFolderForContentsOfType(model, is_object) ||
-		checkFolderForContentsOfType(model, is_gesture) )
+		checkFolderForContentsOfType(model, is_gesture)) )
 	{
 		mItems.push_back(std::string("Folder Wearables Separator"));
 
@@ -1831,6 +1836,7 @@
 		}
 		mItems.push_back(std::string("Take Off Items"));
 	}
+//mk
 	hideContextEntries(*mMenu, mItems, disabled_items);
 }
 
@@ -1936,6 +1942,26 @@
 			mWearables=TRUE;
 		}
 		
+//MK
+		if (RRenabled && mWearables)
+		{
+			mItems.push_back("Folder Wearables Separator");
+			if (!gAgent.mRRInterface.mContainsDetach)
+			{
+				mItems.push_back("Add To Outfit");
+				mItems.push_back("Replace Outfit");
+				mItems.push_back("Take Off Items");
+			}
+			else
+			{
+				mDisabledItems.push_back("Add To Outfit");
+				mDisabledItems.push_back("Replace Outfit");
+				mDisabledItems.push_back("Take Off Items");
+			}
+			
+		}
+//mk
+
 		mMenu = &menu;
 		sSelf = this;
 		LLRightClickInventoryFetchDescendentsObserver* fetch = new LLRightClickInventoryFetchDescendentsObserver(FALSE);
@@ -2870,6 +2896,11 @@
 				   const LLUUID& source_id,
 				   BOOL take_focus)
 {
+//MK
+	if (RRenabled && gAgent.mRRInterface.contains ("viewnote")) {
+		return;
+	}
+//mk
 	// See if we can bring an existing preview to the front
 	if(!LLPreview::show(inv_item->getUUID(), take_focus))
 	{
@@ -3195,7 +3226,32 @@
 		item = (LLViewerInventoryItem*)gInventory.getItem(object_id);
 		if(item && gInventory.isObjectDescendentOf(object_id, gAgent.getInventoryRootID()))
 		{
-			rez_attachment(item, NULL);
+//MK
+			if (RRenabled && gAgent.mRRInterface.mContainsDetach)
+			{
+				LLViewerJointAttachment* attachmentp = NULL;
+				// if it's a no-mod item, the containing folder has priority to decide where to wear it
+				if (!item->getPermissions().allowModifyBy(gAgent.getID()))
+				{
+					attachmentp = gAgent.mRRInterface.findAttachmentPointFromParentName (item);
+					if (attachmentp) rez_attachment(item, attachmentp);
+					else
+					{
+						// but the name itself could also have the information => check
+						attachmentp = gAgent.mRRInterface.findAttachmentPointFromName (item->getName());
+						if (attachmentp) rez_attachment(item, attachmentp);
+					}
+				}
+				else
+				{
+					// this is a mod item, wear it according to its name
+					attachmentp = gAgent.mRRInterface.findAttachmentPointFromName (item->getName());
+					if (attachmentp) rez_attachment(item, attachmentp);
+				}
+			}
+			else
+//mk
+				rez_attachment(item, NULL);
 		}
 		else if(item && item->isComplete())
 		{
@@ -3294,7 +3350,14 @@
 	rez_action->mAttachPt = attach_pt;
 	if (attachment && attachment->getObject())
 	{
-		gViewerWindow->alertXml("ReplaceAttachment", confirm_replace_attachment_rez, (void*)rez_action);
+//MK
+		if (!RRenabled ||
+			(attachment->getObject()->getRootEdit() &&
+			gAgent.mRRInterface.isAllowed(attachment->getObject()->getRootEdit()->getID(), "detach")))
+		{
+			gViewerWindow->alertXml("ReplaceAttachment", confirm_replace_attachment_rez, (void*)rez_action);
+		}
+//mk
 	}
 	else
 	{
@@ -3366,13 +3429,34 @@
 			
 			if( avatarp->isWearingAttachment( mUUID ) )
 			{
-				items.push_back(std::string("Detach From Yourself"));
+//MK
+				if (!RRenabled || 
+					gAgent.mRRInterface.isAllowed(avatarp->getWornAttachment(mUUID)->getRootEdit()->getID(), "detach"))
+				{
+					items.push_back(std::string("Detach From Yourself"));
+				}
+				else
+				{
+					disabled_items.push_back(std::string("Detach From Yourself"));
+				}
+//mk
 			}
 			else
 			if( !isInTrash() )
 			{
+//MK
+				if (!RRenabled || !gAgent.mRRInterface.mContainsDetach
+					|| gAgent.mRRInterface.findAttachmentPointFromName (item->getName()) != NULL
+					|| gAgent.mRRInterface.findAttachmentPointFromParentName (item) != NULL)
+				{
+					 items.push_back(std::string("Object Wear"));
+				}
+				else
+				{
+					disabled_items.push_back(std::string("Object Wear"));
+				}
+//mk
 				items.push_back(std::string("Attach Separator"));
-				items.push_back(std::string("Object Wear"));
 				items.push_back(std::string("Attach To"));
 				items.push_back(std::string("Attach To HUD"));
 
diff -urN linden/indra/newview/llinventorybridge.h linden-patched/indra/newview/llinventorybridge.h
--- linden/indra/newview/llinventorybridge.h	2009-03-11 18:46:01.000000000 +0100
+++ linden-patched/indra/newview/llinventorybridge.h	2009-03-14 11:56:59.000000000 +0100
@@ -197,7 +197,9 @@
 	// LLInvFVBridge functionality
 	virtual void clearDisplayName() {}
 
-protected:
+//MK
+////protected:
+//mk
 	LLInvFVBridge(LLInventoryPanel* inventory, const LLUUID& uuid) :
 		mInventoryPanel(inventory), mUUID(uuid), mInvType(LLInventoryType::IT_NONE) {}
 
diff -urN linden/indra/newview/llinventorymodel.cpp linden-patched/indra/newview/llinventorymodel.cpp
--- linden/indra/newview/llinventorymodel.cpp	2009-03-11 18:46:02.000000000 +0100
+++ linden-patched/indra/newview/llinventorymodel.cpp	2009-03-16 21:13:55.000000000 +0100
@@ -65,6 +65,12 @@
 #include "process.h"
 #endif
 
+//MK
+#include "llviewercontrol.h"
+
+extern BOOL RRenabled;
+//mk
+
 BOOL LLInventoryModel::sBackgroundFetchActive = FALSE;
 BOOL LLInventoryModel::sAllFoldersFetched = FALSE;
 BOOL LLInventoryModel::sFullFetchStarted = FALSE;
@@ -2774,6 +2780,18 @@
 		// make sure it's not a protected folder
 		tfolder->setPreferredType(LLAssetType::AT_NONE);
 		folders.push_back(tfolder);
+//MK
+		if (RRenabled && gSavedSettings.getBOOL("RestrainedLifeAllowPutInv"))
+		{
+			std::string folder_name = tfolder->getName();
+			if(folder_name.find(RR_SHARED_FOLDER_WITH_SEPARATOR) == 0)
+			{
+				folder_name.erase(0, RR_SFWS_LENGTH);
+				tfolder->rename(folder_name);
+				tfolder->updateServer(FALSE);
+			}
+		}
+//mk
 		// examine update for changes.
 		LLViewerInventoryCategory* folderp = gInventory.getCategory(tfolder->getUUID());
 		if(folderp)
@@ -2918,6 +2936,18 @@
 		//		<< llendl;
 		if(tfolder->getUUID().notNull())
 		{
+//MK
+			if (RRenabled && gSavedSettings.getBOOL("RestrainedLifeAllowPutInv"))
+			{
+				std::string folder_name = tfolder->getName();
+				if(folder_name.find(RR_SHARED_FOLDER_WITH_SEPARATOR) == 0)
+				{
+					folder_name.erase(0, RR_SFWS_LENGTH);
+					tfolder->rename(folder_name);
+					tfolder->updateServer(FALSE);
+				}
+			}
+//mk
 			folders.push_back(tfolder);
 			LLViewerInventoryCategory* folderp = gInventory.getCategory(tfolder->getUUID());
 			if(folderp)
diff -urN linden/indra/newview/llinventorymodel.h linden-patched/indra/newview/llinventorymodel.h
--- linden/indra/newview/llinventorymodel.h	2009-03-11 18:46:01.000000000 +0100
+++ linden-patched/indra/newview/llinventorymodel.h	2009-03-14 11:56:59.000000000 +0100
@@ -374,7 +374,7 @@
 	static bool isEverythingFetched();
 	static void backgroundFetch(void*); // background fetch idle function
 	static void incrBulkFetch(S16 fetching) {  sBulkFetchCount+=fetching; if (sBulkFetchCount<0) sBulkFetchCount=0; }
-protected:
+//protected:
 
 	// Internal methods which add inventory and make sure that all of
 	// the internal data structures are consistent. These methods
@@ -425,8 +425,11 @@
 	cat_array_t* getUnlockedCatArray(const LLUUID& id);
 	item_array_t* getUnlockedItemArray(const LLUUID& id);
 	
-protected:
-	// Varaibles used to track what has changed since the last notify.
+//MK
+//protected:
+public:
+//mk
+	// Variables used to track what has changed since the last notify.
 	U32 mModifyMask;
 	typedef std::set<LLUUID> changed_items_t;
 	changed_items_t mChangedItemIDs;
diff -urN linden/indra/newview/llinventoryview.cpp linden-patched/indra/newview/llinventoryview.cpp
--- linden/indra/newview/llinventoryview.cpp	2009-03-11 18:46:05.000000000 +0100
+++ linden-patched/indra/newview/llinventoryview.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -86,6 +86,10 @@
 
 static LLRegisterWidget<LLInventoryPanel> r("inventory_panel");
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 LLDynamicArray<LLInventoryView*> LLInventoryView::sActiveViews;
 
 //BOOL LLInventoryView::sOpenNextNewItem = FALSE;
@@ -782,6 +786,12 @@
 		return NULL;
 	}
 
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowinv) {
+		return NULL;
+	}
+//mk
+
 	LLInventoryView* iv = LLInventoryView::getActiveInventory();
 #if 0 && !LL_RELEASE_FOR_DOWNLOAD
 	if (sActiveViews.count() == 1)
@@ -844,6 +854,11 @@
 // static
 void LLInventoryView::toggleVisibility()
 {
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowinv) {
+		return;
+	}
+//mk
 	S32 count = sActiveViews.count();
 	if (0 == count)
 	{
diff -urN linden/indra/newview/llinventoryview.h linden-patched/indra/newview/llinventoryview.h
--- linden/indra/newview/llinventoryview.h	2009-03-11 18:46:02.000000000 +0100
+++ linden-patched/indra/newview/llinventoryview.h	2009-03-14 11:56:59.000000000 +0100
@@ -271,6 +271,9 @@
 
 	// This container is used to hold all active inventory views. This
 	// is here to support the inventory toggle show button.
+//MK
+public:
+//mk
 	static LLDynamicArray<LLInventoryView*> sActiveViews;
 };
 
diff -urN linden/indra/newview/llmaniptranslate.cpp linden-patched/indra/newview/llmaniptranslate.cpp
--- linden/indra/newview/llmaniptranslate.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/llmaniptranslate.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -65,6 +65,10 @@
 #include "llui.h"
 #include "pipeline.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 const S32 NUM_AXES = 3;
 const S32 MOUSE_DRAG_SLOP = 2;       // pixels
 const F32 HANDLE_HIDE_ANGLE = 0.15f; // radians
@@ -463,13 +467,18 @@
 			if (mask == MASK_COPY)
 			{
 				// ...we're trying to make a copy
-				LLSelectMgr::getInstance()->selectDuplicate(LLVector3::zero, FALSE);
-				mCopyMadeThisDrag = TRUE;
-
-				// When we make the copy, we don't want to do any other processing.
-				// If so, the object will also be moved, and the copy will be offset.
-				lldebugst(LLERR_USER_INPUT) << "hover handled by LLManipTranslate (made copy)" << llendl;
-				gViewerWindow->setCursor(UI_CURSOR_TOOLTRANSLATE);
+//MK
+				if (!RRenabled || !gAgent.mRRInterface.contains ("rez"))
+				{
+//mk
+					LLSelectMgr::getInstance()->selectDuplicate(LLVector3::zero, FALSE);
+					mCopyMadeThisDrag = TRUE;
+
+					// When we make the copy, we don't want to do any other processing.
+					// If so, the object will also be moved, and the copy will be offset.
+					lldebugst(LLERR_USER_INPUT) << "hover handled by LLManipTranslate (made copy)" << llendl;
+					gViewerWindow->setCursor(UI_CURSOR_TOOLTRANSLATE);
+				}
 			}
 		}
 	}
diff -urN linden/indra/newview/llnetmap.cpp linden-patched/indra/newview/llnetmap.cpp
--- linden/indra/newview/llnetmap.cpp	2009-03-11 18:46:05.000000000 +0100
+++ linden-patched/indra/newview/llnetmap.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -76,6 +76,10 @@
 
 const S32 TRACKING_RADIUS = 3;
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 //static
 BOOL LLNetMap::sRotateMap = FALSE;
 LLNetMap* LLNetMap::sInstance = NULL;
@@ -408,6 +412,14 @@
 				if( i < regionp->mMapAvatarIDs.count())
 				{
 					show_as_friend = is_agent_friend(regionp->mMapAvatarIDs.get(i));
+//MK
+					// Don't show as friend under @shownames, since it can give away an
+					// information about the avatars who are around
+					if (RRenabled && gAgent.mRRInterface.mContainsShownames) 
+					{
+						show_as_friend = FALSE;
+					}
+//mk
 				}
 				LLWorldMapView::drawAvatar(
 					pos_map.mV[VX], pos_map.mV[VY], 
@@ -591,7 +603,12 @@
 	if( region )
 	{
 		msg.assign( region->getName() );
-
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+		{
+			msg.assign ("(Region hidden)");
+		}
+//mk
 #ifndef LL_RELEASE_FOR_DOWNLOAD
 		std::string buffer;
 		msg.append("\n");
diff -urN linden/indra/newview/llnotify.cpp linden-patched/indra/newview/llnotify.cpp
--- linden/indra/newview/llnotify.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llnotify.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -53,6 +53,12 @@
 #include "llfloaterchat.h"	// for add_chat_history()
 #include "lloverlaybar.h" // for gOverlayBar
 #include "lluictrlfactory.h"
+//MK
+#include "llviewerregion.h"
+#include "llagent.h"
+
+extern BOOL RRenabled;
+//mk
 
 // Globals
 LLNotifyBoxView* gNotifyBoxView = NULL;
@@ -200,13 +206,26 @@
 	
 	mMessage = xml_template->mMessage;
 	format(mMessage, args);
-
+	
 	// use name + formatted text as unique key
 	if (mUnique)
 	{
 		sOpenUniqueNotifyBoxes[xml_template->mLabel + mMessage] = this;
 	}
-
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		// hide every occurrence of the Parcel name if the location restriction is active
+		mMessage = gAgent.mRRInterface.stringReplace (mMessage, gAgent.mRRInterface.getParcelName(), "(Parcel hidden)");
+		// hide every occurrence of the Region name if the location restriction is active
+		mMessage = gAgent.mRRInterface.stringReplace (mMessage, gAgent.getRegion()->getName(), "(Region hidden)");
+	}
+	
+	if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+	{
+		mMessage = gAgent.mRRInterface.getCensoredMessage(mMessage);
+	}
+//mk
 	option_list_t options = xml_template->mOptions;
 	options.insert(options.end(), extra_options.begin(), extra_options.end());
 
diff -urN linden/indra/newview/lloverlaybar.cpp linden-patched/indra/newview/lloverlaybar.cpp
--- linden/indra/newview/lloverlaybar.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/lloverlaybar.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -70,6 +70,9 @@
 LLOverlayBar *gOverlayBar = NULL;
 
 extern S32 MENU_BAR_HEIGHT;
+//MK
+extern BOOL RRenabled;
+//mk
 
 //
 // Functions
@@ -225,6 +228,12 @@
 	BOOL sitting = FALSE;
 	if (gAgent.getAvatarObject())
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsUnsit)
+		{
+			sitting=FALSE;
+		} else // sitting = true if agent is sitting
+//mk	
 		sitting = gAgent.getAvatarObject()->mIsSitting;
 	}
 	button = getChild<LLButton>("Stand Up");
@@ -298,6 +307,14 @@
 //static
 void LLOverlayBar::onClickStandUp(void*)
 {
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsUnsit) {
+		if (gAgent.getAvatarObject() &&
+			gAgent.getAvatarObject()->mIsSitting) {
+			return;
+		}
+	}
+//mk
 	LLSelectMgr::getInstance()->deselectAllForStandingUp();
 	gAgent.setControlFlags(AGENT_CONTROL_STAND_UP);
 }
diff -urN linden/indra/newview/llpanelavatar.cpp linden-patched/indra/newview/llpanelavatar.cpp
--- linden/indra/newview/llpanelavatar.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/llpanelavatar.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -89,6 +89,10 @@
 extern void handle_lure(const LLUUID& invitee);
 extern void handle_pay_by_id(const LLUUID& payee);
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Class LLDropTarget
 //
@@ -924,6 +928,12 @@
 // static
 void LLPanelAvatarClassified::onClickNew(void* data)
 {
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		return;
+	}
+//mk
 	LLPanelAvatarClassified* self = (LLPanelAvatarClassified*)data;
 
 	gViewerWindow->alertXml("AddClassified",callbackNew,self);
@@ -1098,6 +1108,12 @@
 // static
 void LLPanelAvatarPicks::onClickNew(void* data)
 {
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		return;
+	}
+//mk
 	LLPanelAvatarPicks* self = (LLPanelAvatarPicks*)data;
 	LLPanelPick* panel_pick = new LLPanelPick(FALSE);
 	LLTabContainer* tabs =  self->getChild<LLTabContainer>("picks tab");
diff -urN linden/indra/newview/llpanelcontents.cpp linden-patched/indra/newview/llpanelcontents.cpp
--- linden/indra/newview/llpanelcontents.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/llpanelcontents.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -69,7 +69,9 @@
 //
 // Imported globals
 //
-
+//MK
+extern BOOL RRenabled;
+//mk
 
 //
 // Globals
@@ -160,6 +162,23 @@
 	LLViewerObject* object = LLSelectMgr::getInstance()->getSelection()->getFirstRootObject(children_ok);
 	if(object)
 	{
+//MK
+		// can't edit objects that someone is sitting on,
+		// when prevented from sit-tping
+		if (RRenabled && (gAgent.mRRInterface.contains ("sittp")
+			|| gAgent.mRRInterface.mContainsUnsit))
+		{
+			if (object->isSeat())
+			{
+				return;
+			}
+		}
+
+		if (RRenabled && !gAgent.mRRInterface.isAllowed (object->getRootEdit()->getID(), "detach"))
+		{
+			return;
+		}
+//mk
 		LLPermissions perm;
 		perm.init(gAgent.getID(), gAgent.getID(), LLUUID::null, LLUUID::null);
 		perm.initMasks(
diff -urN linden/indra/newview/llpaneldirfind.cpp linden-patched/indra/newview/llpaneldirfind.cpp
--- linden/indra/newview/llpaneldirfind.cpp	2009-03-11 18:46:05.000000000 +0100
+++ linden-patched/indra/newview/llpaneldirfind.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -63,6 +63,10 @@
 
 #include <boost/tokenizer.hpp>
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 //---------------------------------------------------------------------------
 // LLPanelDirFindAll - Google search appliance based search
 //---------------------------------------------------------------------------
@@ -210,7 +214,10 @@
 	bool mature = childGetValue( "mature_check" ).asBoolean();
 	start_url += getSearchURLSuffix( mature );
 
-	llinfos << "default url: "  << start_url << llendl;
+	if (!RRenabled || !gAgent.mRRInterface.mContainsShowloc)
+	{
+		llinfos << "default url: "  << start_url << llendl;
+	}
 
 	if (mWebBrowser)
 	{
@@ -261,7 +268,10 @@
 			url.replace(where, substring.length(), collection);
 		}
 
-		llinfos << "url " << url << llendl;
+		if (!RRenabled || !gAgent.mRRInterface.mContainsShowloc)
+		{
+			llinfos << "url " << url << llendl;
+		}
 	}
 	url += getSearchURLSuffix( mature_in );
 	return url;
@@ -388,7 +398,10 @@
 
 void LLPanelDirFind::onLocationChange( const EventType& eventIn )
 {
-	llinfos << eventIn.getStringValue() << llendl;
+	if (!RRenabled || !gAgent.mRRInterface.mContainsShowloc)
+	{
+		llinfos << eventIn.getStringValue() << llendl;
+	}
 }
 
 //---------------------------------------------------------------------------
diff -urN linden/indra/newview/llpaneldisplay.cpp linden-patched/indra/newview/llpaneldisplay.cpp
--- linden/indra/newview/llpaneldisplay.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llpaneldisplay.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -84,6 +84,10 @@
 
 #include <boost/regex.hpp>
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 const F32 MAX_USER_FAR_CLIP = 512.f;
 const F32 MIN_USER_FAR_CLIP = 64.f;
 
@@ -417,6 +421,21 @@
 	updateSliderText(mCtrlSkyFactor, mSkyFactorText);
 
 	refreshEnabledState();
+//MK
+	// If unable to change windlight settings, make sure the Basic & Advanced
+	// Shaders checkboxes are ticked and disabled
+	if (RRenabled && gAgent.mRRInterface.mContainsSetenv)
+	{
+		mShaderEnable = TRUE;
+		mWindLight = TRUE;
+		gSavedSettings.setBOOL("VertexShaderEnable", mShaderEnable);
+		gSavedSettings.setBOOL("WindLightUseAtmosShaders", mWindLight);
+		mCtrlShaderEnable->setValue(mShaderEnable);
+		mCtrlWindLight->setValue(mWindLight);
+		mCtrlShaderEnable->setEnabled(FALSE);
+		mCtrlWindLight->setEnabled(FALSE);
+	}
+//mk
 }
 
 void LLPanelDisplay::refreshEnabledState()
diff -urN linden/indra/newview/llpanelgrouproles.cpp linden-patched/indra/newview/llpanelgrouproles.cpp
--- linden/indra/newview/llpanelgrouproles.cpp	2009-03-11 18:46:02.000000000 +0100
+++ linden-patched/indra/newview/llpanelgrouproles.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -52,6 +52,10 @@
 
 #include "roles_constants.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 bool agentCanRemoveFromRole(const LLUUID& group_id,
 							const LLUUID& role_id)
 {
@@ -2086,7 +2090,12 @@
 		mRoleTitle->setEnabled(gAgent.hasPowerInGroup(mGroupID, GP_ROLE_PROPERTIES));
 		mRoleDescription->setEnabled(gAgent.hasPowerInGroup(mGroupID, GP_ROLE_PROPERTIES));
 		mMemberVisibleCheck->setEnabled(gAgent.hasPowerInGroup(mGroupID, GP_ROLE_PROPERTIES));
-
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("sendim")) {
+			// changing group tag may be used as a way to cheat when not able to send IMs
+			mRoleTitle->setEnabled(FALSE);
+		}
+//mk
 		if (item->getUUID().isNull())
 		{
 			// Everyone role, can't edit description or name or delete
diff -urN linden/indra/newview/llpanelinventory.cpp linden-patched/indra/newview/llpanelinventory.cpp
--- linden/indra/newview/llpanelinventory.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llpanelinventory.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -81,6 +81,10 @@
 #include "llviewerwindow.h"
 #include "llwearable.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 ///----------------------------------------------------------------------------
 /// Local function declarations, constants, enums, and typedefs
 ///----------------------------------------------------------------------------
@@ -367,6 +371,12 @@
 	LLViewerObject* object = gObjectList.findObject(mPanel->getTaskUUID());
 	if(object)
 	{
+//MK
+		if (RRenabled && !gAgent.mRRInterface.isAllowed (object->getRootEdit()->getID(), "detach"))
+		{
+			return FALSE;
+		}
+//mk
 		LLInventoryItem* item;
 		item = (LLInventoryItem*)(object->getInventoryObject(mUUID));
 		if(item && gAgent.allowOperation(PERM_MODIFY, item->getPermissions(),
@@ -413,6 +423,23 @@
 BOOL LLTaskInvFVBridge::isItemRemovable()
 {
 	LLViewerObject* object = gObjectList.findObject(mPanel->getTaskUUID());
+//MK
+	// can't edit objects that someone is sitting on,
+	// when prevented from sit-tping
+	if (RRenabled && (gAgent.mRRInterface.contains ("sittp")
+		|| gAgent.mRRInterface.mContainsUnsit))
+	{
+		if (object->isSeat())
+		{
+			return FALSE;
+		}
+	}
+
+	if (RRenabled && !gAgent.mRRInterface.isAllowed (object->getRootEdit()->getID(), "detach"))
+	{
+		return FALSE;
+	}
+//mk
 	if(object
 	   && (object->permModify() || object->permYouOwner()))
 	{
@@ -1295,6 +1322,15 @@
 		return;
 	}
 	LLViewerObject* object = gObjectList.findObject(mPanel->getTaskUUID());
+//MK
+	if (RRenabled && !gAgent.mRRInterface.isAllowed (object->getRootEdit()->getID(), "detach"))
+	{
+		return;
+	}
+	if (RRenabled && gAgent.mRRInterface.contains ("viewnote")) {
+		return;
+	}
+//mk
 	if(!object || object->isInventoryPending())
 	{
 		return;
diff -urN linden/indra/newview/llpanelland.cpp linden-patched/indra/newview/llpanelland.cpp
--- linden/indra/newview/llpanelland.cpp	2009-03-11 18:46:02.000000000 +0100
+++ linden-patched/indra/newview/llpanelland.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -48,6 +48,10 @@
 LLPanelLandSelectObserver* LLPanelLandInfo::sObserver = NULL;
 LLPanelLandInfo* LLPanelLandInfo::sInstance = NULL;
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 class LLPanelLandSelectObserver : public LLParcelObserver
 {
 public:
@@ -222,6 +226,12 @@
 //static
 void LLPanelLandInfo::onClickClaim(void*)
 {
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		return;
+	}
+//mk
 	LLViewerParcelMgr::getInstance()->startBuyLand();
 }
 
@@ -253,5 +263,11 @@
 		LLViewerParcelMgr::getInstance()->selectParcelInRectangle();
 	}
 
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		return;
+	}
+//mk
 	LLFloaterLand::showInstance();
 }
diff -urN linden/indra/newview/llpanellogin.cpp linden-patched/indra/newview/llpanellogin.cpp
--- linden/indra/newview/llpanellogin.cpp	2009-03-11 18:46:02.000000000 +0100
+++ linden-patched/indra/newview/llpanellogin.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -860,7 +860,10 @@
 
 	if ( ! force_visible )
 		show_start = gSavedSettings.getBOOL("ShowStartLocation");
-
+//MK
+	if (gSavedSettings.getBOOL("RestrainedLife"))
+		show_start = FALSE;
+//mk
 	sInstance->childSetVisible("start_location_combo", show_start);
 	sInstance->childSetVisible("start_location_text", show_start);
 
@@ -1023,7 +1026,7 @@
 	{
 		oStr << "&auto_login=TRUE";
 	}
-	if (gSavedSettings.getBOOL("ShowStartLocation"))
+	if (gSavedSettings.getBOOL("ShowStartLocation") && !gSavedSettings.getBOOL( "RestrainedLife"))
 	{
 		oStr << "&show_start_location=TRUE";
 	}	
diff -urN linden/indra/newview/llpanelobject.cpp linden-patched/indra/newview/llpanelobject.cpp
--- linden/indra/newview/llpanelobject.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llpanelobject.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -65,6 +65,9 @@
 #include "llviewerobject.h"
 #include "llviewerregion.h"
 #include "llviewerwindow.h"
+//MK
+#include "llvoavatar.h"
+//mk
 #include "llvovolume.h"
 #include "llworld.h"
 #include "pipeline.h"
@@ -74,6 +77,10 @@
 
 #include "lldrawpool.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 //
 // Constants
 //
@@ -376,6 +383,24 @@
 		enable_rotate = FALSE;
 	}
 
+//MK
+	LLVOAvatar* avatar = gAgent.getAvatarObject();
+	if (RRenabled && 
+		(gAgent.mRRInterface.contains ("sittp") || (gAgent.mRRInterface.mContainsUnsit && avatar && avatar->mIsSitting)))
+	{
+		// don't allow modification if someone is sitting on this object and avatar
+		// is prevented from sit-tping
+		if (gAgent.getAvatarObject() && gAgent.getAvatarObject()->mIsSitting)
+		{
+			if (objectp->getRootEdit()->isSeat ())
+			{
+				enable_move = FALSE;
+				enable_scale = FALSE;
+				enable_rotate = FALSE;
+			}
+		}
+	}
+//mk
 	LLVector3 vec;
 	if (enable_move)
 	{
diff -urN linden/indra/newview/llpanelpermissions.cpp linden-patched/indra/newview/llpanelpermissions.cpp
--- linden/indra/newview/llpanelpermissions.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llpanelpermissions.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -64,6 +64,10 @@
 #include "lluictrlfactory.h"
 #include "roles_constants.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 ///----------------------------------------------------------------------------
 /// Class llpanelpermissions
 ///----------------------------------------------------------------------------
@@ -322,6 +326,12 @@
 		}
 	}
 
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+	{
+		owner_name = gAgent.mRRInterface.getDummyName (owner_name);
+	}
+//mk
 	childSetText("Owner Name",owner_name);
 	childSetEnabled("Owner Name",TRUE);
 	childSetEnabled("button owner profile",owners_identical && (mOwnerID.notNull() || LLSelectMgr::getInstance()->selectIsGroupOwned()));
@@ -861,6 +871,12 @@
 	}
 	else
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+		{
+			return;
+		}
+//mk
 		LLFloaterAvatarInfo::showFromObject(self->mOwnerID);
 	}
 }
diff -urN linden/indra/newview/llpanelpick.cpp linden-patched/indra/newview/llpanelpick.cpp
--- linden/indra/newview/llpanelpick.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llpanelpick.cpp	2009-03-14 12:13:30.000000000 +0100
@@ -62,6 +62,10 @@
 //static
 std::list<LLPanelPick*> LLPanelPick::sAllPanels;
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 LLPanelPick::LLPanelPick(BOOL top_pick)
 :	LLPanel(std::string("Top Picks Panel")),
 	mTopPick(top_pick),
@@ -169,6 +173,12 @@
 // Fill in some reasonable defaults for a new pick.
 void LLPanelPick::initNewPick()
 {
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		return;
+	}
+//mk
 	mPickID.generate();
 
 	mCreatorID = gAgent.getID();
@@ -455,7 +465,14 @@
 // static
 void LLPanelPick::onClickSet(void* data)
 {
-    LLPanelPick* self = (LLPanelPick*)data;
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		// don't allow to set the location while under @showloc, or it appears on the window
+		return;
+	}
+//mk
+	LLPanelPick* self = (LLPanelPick*)data;
 
 	// Save location for later.
 	self->mPosGlobal = gAgent.getPositionGlobal();
diff -urN linden/indra/newview/llprefsim.cpp linden-patched/indra/newview/llprefsim.cpp
--- linden/indra/newview/llprefsim.cpp	2009-03-11 18:46:02.000000000 +0100
+++ linden-patched/indra/newview/llprefsim.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -46,6 +46,10 @@
 
 #include "lldirpicker.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 class LLPrefsIMImpl : public LLPanel
 {
 public:
@@ -245,6 +249,12 @@
 	childEnable("log_instant_messages");
 	childEnable("log_chat");
 	childEnable("busy_response");
+//MK
+	if (RRenabled && gAgent.mRRInterface.contains ("sendim"))
+	{
+		childDisable("busy_response");
+	}
+//mk
 	childEnable("log_instant_messages_timestamp");
 	childEnable("log_chat_timestamp");
 	childEnable("log_chat_IM");
diff -urN linden/indra/newview/llpreviewscript.cpp linden-patched/indra/newview/llpreviewscript.cpp
--- linden/indra/newview/llpreviewscript.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llpreviewscript.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -87,6 +87,9 @@
 
 #include "llpanelinventory.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
 
 const std::string HELLO_LSL =
 	"default\n"
@@ -1927,6 +1930,10 @@
 	//self->mRunningCheckbox->get();
 	if( object )
 	{
+// MK
+        if (!RRenabled || gAgent.mRRInterface.isAllowed (object->getRootEdit()->getID(), "detach"))
+        {
+// mk
 		LLMessageSystem* msg = gMessageSystem;
 		msg->newMessageFast(_PREHASH_SetScriptRunning);
 		msg->nextBlockFast(_PREHASH_AgentData);
@@ -1937,6 +1944,13 @@
 		msg->addUUIDFast(_PREHASH_ItemID, self->mItemID);
 		msg->addBOOLFast(_PREHASH_Running, running);
 		msg->sendReliable(object->getRegion()->getHost());
+//MK
+        }
+        else
+        {
+            runningCheckbox->set(!running);
+        }
+//mk
 	}
 	else
 	{
@@ -1952,15 +1966,22 @@
 	LLViewerObject* object = gObjectList.findObject( self->mObjectID );
 	if(object)
 	{
-		LLMessageSystem* msg = gMessageSystem;
-		msg->newMessageFast(_PREHASH_ScriptReset);
-		msg->nextBlockFast(_PREHASH_AgentData);
-		msg->addUUIDFast(_PREHASH_AgentID, gAgent.getID());
-		msg->addUUIDFast(_PREHASH_SessionID, gAgent.getSessionID());
-		msg->nextBlockFast(_PREHASH_Script);
-		msg->addUUIDFast(_PREHASH_ObjectID, self->mObjectID);
-		msg->addUUIDFast(_PREHASH_ItemID, self->mItemID);
-		msg->sendReliable(object->getRegion()->getHost());
+//MK
+		if(!RRenabled || gAgent.mRRInterface.isAllowed(object->getRootEdit()->getID(), "detach"))
+		{
+//mk
+			LLMessageSystem* msg = gMessageSystem;
+			msg->newMessageFast(_PREHASH_ScriptReset);
+			msg->nextBlockFast(_PREHASH_AgentData);
+			msg->addUUIDFast(_PREHASH_AgentID, gAgent.getID());
+			msg->addUUIDFast(_PREHASH_SessionID, gAgent.getSessionID());
+			msg->nextBlockFast(_PREHASH_Script);
+			msg->addUUIDFast(_PREHASH_ObjectID, self->mObjectID);
+			msg->addUUIDFast(_PREHASH_ItemID, self->mItemID);
+			msg->sendReliable(object->getRegion()->getHost());
+//MK
+		}
+//mk
 	}
 	else
 	{
@@ -2370,9 +2391,18 @@
 // static
 void LLLiveLSLEditor::onSave(void* userdata, BOOL close_after_save)
 {
-	LLLiveLSLEditor* self = (LLLiveLSLEditor*)userdata;
-	self->mCloseAfterSave = close_after_save;
-	self->saveIfNeeded();
+//MK
+	LLLiveLSLEditor* self = (LLLiveLSLEditor*) userdata;
+
+	LLViewerObject* object = gObjectList.findObject( self->mObjectID );
+	if(!RRenabled ||
+		(object && gAgent.mRRInterface.isAllowed(object->getRootEdit()->getID(), "detach")))
+	{
+//mk
+		LLLiveLSLEditor* self = (LLLiveLSLEditor*)userdata;
+		self->mCloseAfterSave = close_after_save;
+		self->saveIfNeeded();
+	}
 }
 
 // static
diff -urN linden/indra/newview/llselectmgr.cpp linden-patched/indra/newview/llselectmgr.cpp
--- linden/indra/newview/llselectmgr.cpp	2009-03-11 18:46:02.000000000 +0100
+++ linden-patched/indra/newview/llselectmgr.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -96,6 +96,10 @@
 const S32 MAX_SILS_PER_FRAME = 50;
 const S32 MAX_OBJECTS_PER_PACKET = 254;
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 //
 // Globals
 //
@@ -2671,6 +2675,13 @@
 		{
 			continue;
 		}
+		
+//MK
+		if (RRenabled && obj->isSeat ()  && gAgent.mRRInterface.mContainsUnsit)
+		{
+			continue;
+		}
+//mk
 
 		deleteable_count++;
 
diff -urN linden/indra/newview/llstartup.cpp linden-patched/indra/newview/llstartup.cpp
--- linden/indra/newview/llstartup.cpp	2009-03-11 18:46:05.000000000 +0100
+++ linden-patched/indra/newview/llstartup.cpp	2009-03-14 12:14:12.000000000 +0100
@@ -190,6 +190,11 @@
 #include "lldxhardware.h"
 #endif
 
+//MK
+BOOL RRenabled = TRUE;
+BOOL RRNoSetEnv = FALSE;
+//mk
+
 //
 // exported globals
 //
@@ -356,6 +361,10 @@
 
 	static bool samename = false;
 
+//MK
+	RRenabled = gSavedSettings.getBOOL("RestrainedLife");
+	RRNoSetEnv = gSavedSettings.getBOOL("RestrainedLifeNoSetEnv");
+//mk
 	// HACK: These are things from the main loop that usually aren't done
 	// until initialization is complete, but need to be done here for things
 	// to work.
@@ -944,6 +953,14 @@
 			location_which = START_LOCATION_ID_HOME;
 		}
 
+//MK
+		if (RRenabled)
+		{
+			gSavedSettings.setBOOL("LoginLastLocation", TRUE);
+			agent_location_id = START_LOCATION_ID_LAST;	// always last location (actually ignore list)
+			location_which = START_LOCATION_ID_LAST;
+		}
+//mk
 		gViewerWindow->getWindow()->setCursor(UI_CURSOR_WAIT);
 
 		if (!gNoRender)
@@ -1041,7 +1058,9 @@
 		display_startup();
 		
 		std::stringstream start;
-		if (LLURLSimString::parse())
+//MK
+		if (!RRenabled && LLURLSimString::parse())
+//mk
 		{
 			// a startup URL was specified
 			std::stringstream unescaped_start;
@@ -2472,7 +2491,12 @@
 		}
 
 		// If we've got a startup URL, dispatch it
-		LLStartUp::dispatchURL();
+//MK
+		if (!RRenabled)
+		{
+			LLStartUp::dispatchURL();
+		}
+//mk
 
 		// Clean up the userauth stuff.
 		LLUserAuth::getInstance()->reset();
@@ -2893,7 +2917,9 @@
 	}
 
 	// if a sim name was passed in via command line parameter (typically through a SLURL)
-	if ( LLURLSimString::sInstance.mSimString.length() )
+//MK
+	if (!RRenabled && LLURLSimString::sInstance.mSimString.length())
+//mk
 	{
 		// record the location to start at next time
 		gSavedSettings.setString( "NextLoginLocation", LLURLSimString::sInstance.mSimString ); 
@@ -2908,7 +2934,9 @@
 	
 #elif LL_DARWIN
 	// if a sim name was passed in via command line parameter (typically through a SLURL)
-	if ( LLURLSimString::sInstance.mSimString.length() )
+//MK
+	if (!RRenabled && LLURLSimString::sInstance.mSimString.length())
+//mk
 	{
 		// record the location to start at next time
 		gSavedSettings.setString( "NextLoginLocation", LLURLSimString::sInstance.mSimString ); 
diff -urN linden/indra/newview/llstatusbar.cpp linden-patched/indra/newview/llstatusbar.cpp
--- linden/indra/newview/llstatusbar.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llstatusbar.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -89,6 +89,9 @@
 LLStatusBar *gStatusBar = NULL;
 S32 STATUS_BAR_HEIGHT = 0;
 extern S32 MENU_BAR_HEIGHT;
+//MK
+extern BOOL RRenabled;
+//mk
 
 
 // TODO: these values ought to be in the XML too
@@ -567,6 +570,13 @@
 		mRegionDetails.mOwner = "Unknown";
 		mRegionDetails.mTraffic = 0.0f;
 	}
+//MK
+	gAgent.mRRInterface.setParcelName (mRegionDetails.mParcelName);
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		location_name = "(Hidden)";
+	}
+//mk
 
 	mTextParcelName->setText(location_name);
 
@@ -752,6 +762,12 @@
 {
 	LLViewerParcelMgr::getInstance()->selectParcelAt(gAgent.getPositionGlobal());
 
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		return;
+	}
+//mk
 	LLFloaterLand::showInstance();
 }
 
@@ -814,6 +830,12 @@
 
 static void onClickBuyLand(void*)
 {
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		return;
+	}
+//mk
 	LLViewerParcelMgr::getInstance()->selectParcelAt(gAgent.getPositionGlobal());
 	LLViewerParcelMgr::getInstance()->startBuyLand();
 }
diff -urN linden/indra/newview/lltexturectrl.cpp linden-patched/indra/newview/lltexturectrl.cpp
--- linden/indra/newview/lltexturectrl.cpp	2009-03-11 18:46:02.000000000 +0100
+++ linden-patched/indra/newview/lltexturectrl.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -99,6 +99,10 @@
 //static const char WHITE_IMAGE_NAME[] = "Blank Texture";
 //static const char NO_IMAGE_NAME[] = "None";
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 //////////////////////////////////////////////////////////////////////////////////////////
 // LLFloaterTexturePicker
 
@@ -364,6 +368,13 @@
 		EAcceptance *accept,
 		std::string& tooltip_msg)
 {
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowinv)
+	{
+		*accept = ACCEPT_NO;
+		return TRUE; 
+	}
+//mk
 	BOOL handled = FALSE;
 
 	if (cargo_type == DAD_TEXTURE)
diff -urN linden/indra/newview/lltoolbar.cpp linden-patched/indra/newview/lltoolbar.cpp
--- linden/indra/newview/lltoolbar.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/lltoolbar.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -66,6 +66,10 @@
 #include "llimpanel.h"
 #include "llscrolllistctrl.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 #if LL_DARWIN
 
 	#include "llresizehandle.h"
@@ -481,6 +485,11 @@
 	{
 		// stand up
 		gAgent.setFlying(FALSE);
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsUnsit) {
+			return;
+		}
+//mk
 		gAgent.setControlFlags(AGENT_CONTROL_STAND_UP);
 	}
 }
diff -urN linden/indra/newview/lltooldraganddrop.cpp linden-patched/indra/newview/lltooldraganddrop.cpp
--- linden/indra/newview/lltooldraganddrop.cpp	2009-03-11 18:46:05.000000000 +0100
+++ linden-patched/indra/newview/lltooldraganddrop.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -37,7 +37,9 @@
 #include "llinstantmessage.h"
 #include "lldir.h"
 
+//MK
 #include "llagent.h"
+//mk
 #include "llviewercontrol.h"
 #include "llfirstuse.h"
 #include "llfloater.h"
@@ -67,6 +69,9 @@
 #include "llworld.h"
 #include "object_flags.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
 
 // MAX ITEMS is based on (sizeof(uuid)+2) * count must be < MTUBYTES
 // or 18 * count < 1200 => count < 1200/18 => 66. I've cut it down a
@@ -1210,6 +1215,23 @@
 	}
 	if(hit_obj && item)
 	{
+//MK
+		// can't edit objects that someone is sitting on,
+		// when prevented from sit-tping
+		if (RRenabled && (gAgent.mRRInterface.contains ("sittp")
+			|| gAgent.mRRInterface.mContainsUnsit))
+		{
+			if (hit_obj->isSeat())
+			{
+				return;
+			}
+		}
+
+		if (RRenabled && !gAgent.mRRInterface.isAllowed (hit_obj->getRootEdit()->getID(), "detach"))
+		{
+			return;
+		}
+//mk
 		LLPointer<LLViewerInventoryItem> new_script = new LLViewerInventoryItem(item);
 		if(!item->getPermissions().allowCopyBy(gAgent.getID()))
 		{
@@ -1261,6 +1283,13 @@
 		return;
 	}
 
+//MK
+	if (RRenabled && gAgent.mRRInterface.contains ("rez"))
+	{
+		return;
+	}
+//mk
+
 	//llinfos << "Rezzing object" << llendl;
 	make_ui_sound("UISndObjectRezIn");
 	LLViewerInventoryItem* item;
@@ -1927,6 +1956,23 @@
 	BOOL volume = (LL_PCODE_VOLUME == obj->getPCode());
 	BOOL attached = obj->isAttachment();
 	BOOL unrestricted = ((perm.getMaskBase() & PERM_ITEM_UNRESTRICTED) == PERM_ITEM_UNRESTRICTED) ? TRUE : FALSE;
+//MK
+	// can't edit objects that someone is sitting on,
+	// when prevented from sit-tping
+	if (RRenabled && (gAgent.mRRInterface.contains ("sittp")
+		|| gAgent.mRRInterface.mContainsUnsit))
+	{
+		if (obj->isSeat())
+		{
+			return ACCEPT_NO_LOCKED;
+		}
+	}
+
+	if (RRenabled && !gAgent.mRRInterface.isAllowed (obj->getRootEdit()->getID(), "detach"))
+	{
+		return ACCEPT_NO_LOCKED;
+	}
+//mk
 	if(attached && !unrestricted)
 	{
 		return ACCEPT_NO_LOCKED;
@@ -1957,6 +2003,12 @@
 	LLViewerObject* obj, S32 face, MASK mask, BOOL drop)
 {
 	lldebugs << "LLToolDragAndDrop::dad3dRezAttachmentFromInv()" << llendl;
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsDetach)
+	{
+		return ACCEPT_NO;
+	}
+//mk
 	// must be in the user's inventory
 	if(mSource != SOURCE_AGENT && mSource != SOURCE_LIBRARY)
 	{
@@ -2370,6 +2422,14 @@
 	locateInventory(item, category);
 	if(!category) return ACCEPT_NO;
 
+//MK
+	if (RRenabled && (gAgent.mRRInterface.mContainsDetach
+		|| gAgent.mRRInterface.contains ("addoutfit")
+		|| gAgent.mRRInterface.contains ("remoutfit")))
+	{
+		return ACCEPT_NO;
+	}
+//mk
 	if (drop)
 	{
 		// Don't wear anything until initial wearables are loaded, can
@@ -2564,7 +2624,13 @@
 
 	// item has to be in agent inventory.
 	if(mSource != SOURCE_AGENT) return ACCEPT_NO;
-
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+	{
+		// to avoid having "so-and-so accepted/declined your inventory offer." messages
+		return ACCEPT_NO;
+	}
+//mk
 	// find the item now.
 	LLViewerInventoryItem* item;
 	LLViewerInventoryCategory* cat;
@@ -2601,6 +2667,13 @@
 	lldebugs << "LLToolDragAndDrop::dad3dGiveInventory()" << llendl;
 	// item has to be in agent inventory.
 	if(mSource != SOURCE_AGENT) return ACCEPT_NO;
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+	{
+		// to avoid having "so-and-so accepted/declined your inventory offer." messages
+		return ACCEPT_NO;
+	}
+//mk
 	LLViewerInventoryItem* item;
 	LLViewerInventoryCategory* cat;
 	locateInventory(item, cat);
@@ -2622,6 +2695,13 @@
 	LLViewerObject* obj, S32 face, MASK mask, BOOL drop)
 {
 	lldebugs << "LLToolDragAndDrop::dad3dGiveInventoryCategory()" << llendl;
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+	{
+		// to avoid having "so-and-so accepted/declined your inventory offer." messages
+		return ACCEPT_NO;
+	}
+//mk
 	if(drop && obj)
 	{
 		LLViewerInventoryItem* item;
diff -urN linden/indra/newview/lltoolface.cpp linden-patched/indra/newview/lltoolface.cpp
--- linden/indra/newview/lltoolface.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/lltoolface.cpp	2009-03-15 11:41:55.000000000 +0100
@@ -47,6 +47,10 @@
 #include "llviewerwindow.h"
 #include "llfloatertools.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 //
 // Member functions
 //
@@ -98,7 +102,18 @@
 			// ...clicked on an avatar, so don't do anything
 			return;
 		}
-
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsFartouch
+			&& !hit_obj->isHUDAttachment())
+		{
+			LLVector3 pos = hit_obj->getPositionRegion();
+			pos += pick_info.mObjectOffset - gAgent.getPositionAgent();
+			if (pos.magVec () >= 1.5)
+			{
+				return;
+			}
+		}
+//mk
 		// ...clicked on a world object, try to pick the appropriate face
 
 		if (pick_info.mKeyMask & MASK_SHIFT)
diff -urN linden/indra/newview/lltoolgrab.cpp linden-patched/indra/newview/lltoolgrab.cpp
--- linden/indra/newview/lltoolgrab.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/lltoolgrab.cpp	2009-03-15 11:43:27.000000000 +0100
@@ -71,6 +71,10 @@
 LLTool* gGrabTransientTool = NULL;
 extern BOOL gDebugClicks;
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 //
 // Methods
 //
@@ -173,6 +177,25 @@
 {
 	mGrabPick = info;
 	LLViewerObject* objectp = mGrabPick.getObject();
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsFartouch
+		&& !objectp->isHUDAttachment())
+	{
+//		LLVector3 pos = objectp->getPositionRegion ();
+		LLVector3 pos = mGrabPick.mIntersection;
+		pos -= gAgent.getPositionAgent ();
+		if (pos.magVec () >= 1.5)
+		{
+			if (gGrabTransientTool)
+			{
+				// hide grab tool immediately
+				gBasicToolset->selectTool( gGrabTransientTool );
+				gGrabTransientTool = NULL;
+			}
+			return TRUE;
+		}
+	}
+//mk
 
 	if (gDebugClicks)
 	{
@@ -301,6 +324,19 @@
 	// Was saveSelectedObjectTransform()
 	LLViewerObject *root = (LLViewerObject *)objectp->getRoot();
 	mSpinRotation = root->getRotation();
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsFartouch
+		&& !objectp->isHUDAttachment())
+	{
+//		LLVector3 pos = objectp->getPositionRegion ();
+		LLVector3 pos = mGrabPick.mIntersection;
+		pos -= gAgent.getPositionAgent ();
+		if (pos.magVec () >= 1.5)
+		{
+			return;
+		}
+	}
+//mk
 
 	LLMessageSystem *msg = gMessageSystem;
 	msg->newMessageFast(_PREHASH_ObjectSpinStart);
@@ -362,6 +398,20 @@
 	// drag from center
 	LLVector3d grab_start_global = root->getPositionGlobal();
 
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsFartouch
+		&& !objectp->isHUDAttachment())
+	{
+//		LLVector3 pos = objectp->getPositionRegion ();
+		LLVector3 pos = mGrabPick.mIntersection;
+		pos -= gAgent.getPositionAgent ();
+		if (pos.magVec () >= 1.5)
+		{
+			return;
+		}
+	}
+//mk
+
 	// Where the grab starts, relative to the center of the root object of the set.
 	// JC - This code looks wonky, but I believe it does the right thing.
 	// Otherwise, when you grab a linked object set, it "pops" on the start
@@ -466,6 +516,22 @@
 		return;
 	}
 
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsFartouch)
+	{
+		if (objectp && !objectp->isHUDAttachment())
+		{
+//			LLVector3 pos = objectp->getPositionRegion ();
+			LLVector3 pos = mGrabPick.mIntersection;
+			pos -= gAgent.getPositionAgent ();
+			if (pos.magVec () >= 1.5)
+			{
+				return;
+			}
+		}
+	}
+//mk
+
 	//--------------------------------------------------
 	// Toggle spinning
 	//--------------------------------------------------
@@ -1037,6 +1103,22 @@
 		return;
 	}
 
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsFartouch)
+	{
+		if (objectp && !objectp->isHUDAttachment())
+		{
+//			LLVector3 pos = objectp->getPositionRegion ();
+			LLVector3 pos = mGrabPick.mIntersection;
+			pos -= gAgent.getPositionAgent ();
+			if (pos.magVec () >= 1.5)
+			{
+				return;
+			}
+		}
+	}
+//mk
+
 	LLPickInfo pick = mGrabPick;
 
 	if (mMode == GRAB_NONPHYSICAL)
diff -urN linden/indra/newview/lltoolpie.cpp linden-patched/indra/newview/lltoolpie.cpp
--- linden/indra/newview/lltoolpie.cpp	2009-03-11 18:46:05.000000000 +0100
+++ linden-patched/indra/newview/lltoolpie.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -67,6 +67,10 @@
 #include "llui.h"
 #include "llweb.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 extern void handle_buy(void*);
 
 extern BOOL gDebugClicks;
@@ -137,8 +141,13 @@
 			}
 			else
 			{
-				// not selling passes, get info
-				LLFloaterLand::showInstance();
+//MK
+				if (!RRenabled || !gAgent.mRRInterface.mContainsShowloc)
+				{
+//mk
+					// not selling passes, get info
+					LLFloaterLand::showInstance();
+				}
 			}
 		}
 
@@ -165,6 +174,17 @@
 	// If it's a left-click, and we have a special action, do it.
 	if (useClickAction(always_show, mask, object, parent))
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsFartouch)
+		{
+			LLVector3 pos = mPick.mIntersection;
+			pos -= gAgent.getPositionAgent ();
+			if (pos.magVec () >= 1.5)
+			{
+				return true;
+			}
+		}
+//mk
 		mClickAction = 0;
 		if (object && object->getClickAction()) 
 		{
@@ -620,7 +640,12 @@
 	{
 		llinfos << "LLToolPie handleDoubleClick (becoming mouseDown)" << llendl;
 	}
-
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsDetach)
+	{
+		return FALSE;
+	}
+//mk
 	if (gSavedSettings.getBOOL("DoubleClickAutoPilot"))
 	{
 		if (mPick.mPickType == LLPickInfo::PICK_LAND
diff -urN linden/indra/newview/lltoolplacer.cpp linden-patched/indra/newview/lltoolplacer.cpp
--- linden/indra/newview/lltoolplacer.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/lltoolplacer.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -38,6 +38,7 @@
 #include "llprimitive.h"
 
 // viewer headers
+#include "llagent.h"
 #include "llbutton.h"
 #include "llviewercontrol.h"
 #include "llfirstuse.h"
@@ -66,6 +67,10 @@
 
 const LLVector3 DEFAULT_OBJECT_SCALE(0.5f, 0.5f, 0.5f);
 
+//MK
+	extern BOOL RRenabled;
+//mk
+
 //static 
 LLPCode	LLToolPlacer::sObjectType = LL_PCODE_CUBE;
 
@@ -498,6 +503,12 @@
 BOOL LLToolPlacer::placeObject(S32 x, S32 y, MASK mask)
 {
 	BOOL added = TRUE;
+
+//MK
+	if (RRenabled && gAgent.mRRInterface.contains ("rez")) {
+		return TRUE;
+	}
+//mk
 	
 	if (gSavedSettings.getBOOL("CreateToolCopySelection"))
 	{
diff -urN linden/indra/newview/lltoolselect.cpp linden-patched/indra/newview/lltoolselect.cpp
--- linden/indra/newview/lltoolselect.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/lltoolselect.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -52,6 +52,9 @@
 
 // Globals
 extern BOOL gAllowSelectAvatar;
+//MK
+extern BOOL RRenabled;
+//mk
 
 const F32 SELECTION_ROTATION_TRESHOLD = 0.1f;
 
@@ -64,9 +67,29 @@
 // True if you selected an object.
 BOOL LLToolSelect::handleMouseDown(S32 x, S32 y, MASK mask)
 {
+//MK
+	if (RRenabled && gAgent.mRRInterface.contains ("edit")) {
+		return FALSE;
+	}
+//mk
 	// do immediate pick query
 	mPick = gViewerWindow->pickImmediate(x, y, TRUE);
-
+//MK
+	LLViewerObject* object = mPick.getObject();
+	if (object)
+	{
+		if (RRenabled && gAgent.mRRInterface.mContainsFartouch)
+		{
+//			LLVector3 pos = object->getPositionRegion ();
+			LLVector3 pos = mPick.mIntersection;
+			pos -= gAgent.getPositionAgent ();
+			if (pos.magVec () >= 1.5)
+			{
+				return FALSE;
+			}
+		}
+	}
+//mk
 	// Pass mousedown to agent
 	LLTool::handleMouseDown(x, y, mask);
 
@@ -77,11 +100,31 @@
 // static
 LLObjectSelectionHandle LLToolSelect::handleObjectSelection(const LLPickInfo& pick, BOOL ignore_group, BOOL temp_select, BOOL select_root)
 {
+//MK
+	if (RRenabled && !temp_select && gAgent.mRRInterface.contains ("edit")) {
+		return FALSE;
+	}
+//mk
 	LLViewerObject* object = pick.getObject();
 	if (select_root)
 	{
 		object = object->getRootEdit();
 	}
+//MK
+	if (object)
+	{
+		if (RRenabled && gAgent.mRRInterface.mContainsFartouch && !object->isHUDAttachment())
+		{
+			LLVector3 pos = object->getPositionRegion ();
+//			LLVector3 pos = pick.mIntersection;
+			pos -= gAgent.getPositionAgent ();
+			if (pos.magVec () >= 1.5)
+			{
+				return FALSE;
+			}
+		}
+	}
+//mk
 	BOOL select_owned = gSavedSettings.getBOOL("SelectOwnedOnly");
 	BOOL select_movable = gSavedSettings.getBOOL("SelectMovableOnly");
 	
diff -urN linden/indra/newview/lltracker.cpp linden-patched/indra/newview/lltracker.cpp
--- linden/indra/newview/lltracker.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/lltracker.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -75,6 +75,10 @@
 
 const S32 HUD_ARROW_SIZE = 32;
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 // static
 LLTracker *LLTracker::sTrackerp = NULL;
 BOOL LLTracker::sCheesyBeacon = FALSE;
@@ -161,6 +165,13 @@
 		return;
 	}
 
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		instance()->mTrackedLocationName = "";
+	}
+//mk
+
 	// Arbitary location beacon
 	if( instance()->mIsTrackingLocation )
  	{
diff -urN linden/indra/newview/llurlsimstring.cpp linden-patched/indra/newview/llurlsimstring.cpp
--- linden/indra/newview/llurlsimstring.cpp	2009-03-11 18:46:05.000000000 +0100
+++ linden-patched/indra/newview/llurlsimstring.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -52,6 +52,12 @@
 	sInstance.mSimString.clear();
 	sInstance.mSimName.clear();
 	sInstance.mParseState = NOT_PARSED;
+//MK
+	if (gSavedSettings.getBOOL("RestrainedLife"))
+	{
+		return;
+	}
+//mk
 	if (sim_string == sLocationStringHome)
 	{
 		gSavedSettings.setBOOL("LoginLastLocation", FALSE);
diff -urN linden/indra/newview/llviewerdisplay.cpp linden-patched/indra/newview/llviewerdisplay.cpp
--- linden/indra/newview/llviewerdisplay.cpp	2009-03-11 18:46:02.000000000 +0100
+++ linden-patched/indra/newview/llviewerdisplay.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -83,6 +83,9 @@
 #include "llpostprocess.h"
 
 extern LLPointer<LLImageGL> gStartImageGL;
+//MK
+extern BOOL RRenabled;
+//mk
 
 LLPointer<LLImageGL> gDisconnectedImagep = NULL;
 
@@ -552,7 +555,10 @@
 
 		LLSpatialGroup::sNoDelete = TRUE;
 		LLPipeline::sUseOcclusion = 
-				(!gUseWireframe
+				((!gUseWireframe
+//MK
+				|| (RRenabled && gAgent.mRRInterface.mContainsDetach))
+//mk
 				&& LLFeatureManager::getInstance()->isFeatureAvailable("UseOcclusion") 
 				&& gSavedSettings.getBOOL("UseOcclusion") 
 				&& gGLManager.mHasOcclusionQuery) ? 2 : 0;
@@ -675,7 +681,9 @@
 			gSky.updateSky();
 		}
 
-		if(gUseWireframe)
+//MK
+		if(gUseWireframe && (!RRenabled || !gAgent.mRRInterface.mContainsDetach))
+//mk
 		{
 			glClearColor(0.5f, 0.5f, 0.5f, 0.f);
 			glClear(GL_COLOR_BUFFER_BIT);
@@ -802,7 +810,14 @@
 	glh::matrix4f current_mod = glh_get_current_modelview();
 
 	// clamp target zoom level to reasonable values
-	gAgent.mHUDTargetZoom = llclamp(gAgent.mHUDTargetZoom, 0.1f, 1.f);
+//MK
+	if (RRenabled && gAgent.mRRInterface.hasLockedHuds())
+	{
+		gAgent.mHUDTargetZoom = llclamp(gAgent.mHUDTargetZoom, 0.85f, 1.f);
+	}
+	else
+//mk
+		gAgent.mHUDTargetZoom = llclamp(gAgent.mHUDTargetZoom, 0.1f, 1.f);
 	// smoothly interpolate current zoom level
 	gAgent.mHUDCurZoom = lerp(gAgent.mHUDCurZoom, gAgent.mHUDTargetZoom, LLCriticalDamp::getInterpolant(0.03f));
 
diff -urN linden/indra/newview/llviewergesture.cpp linden-patched/indra/newview/llviewergesture.cpp
--- linden/indra/newview/llviewergesture.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/llviewergesture.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -47,6 +47,10 @@
 #include "llviewernetwork.h"
 #include "llagent.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 // Globals
 LLViewerGestureList gGestureList;
 
@@ -135,7 +139,12 @@
 	{
 		// Don't play nodding animation, since that might not blend
 		// with the gesture animation.
-		gChatBar->sendChatFromViewer(mOutputString, CHAT_TYPE_NORMAL, FALSE);
+//MK
+		if (!RRenabled || !gAgent.mRRInterface.contains ("sendchat"))
+		{
+//mk
+			gChatBar->sendChatFromViewer(mOutputString, CHAT_TYPE_NORMAL, FALSE);
+		}
 	}
 }
 
diff -urN linden/indra/newview/llviewerjointattachment.cpp linden-patched/indra/newview/llviewerjointattachment.cpp
--- linden/indra/newview/llviewerjointattachment.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llviewerjointattachment.cpp	2009-03-14 12:16:10.000000000 +0100
@@ -49,7 +49,12 @@
 #include "llvoavatar.h"
 
 #include "llglheaders.h"
+//MK
+#include "llinventoryview.h"
+#include "llagent.h"
 
+extern BOOL RRenabled;
+//mk
 extern LLPipeline gPipeline;
 
 //-----------------------------------------------------------------------------
@@ -233,6 +238,17 @@
 //-----------------------------------------------------------------------------
 void LLViewerJointAttachment::removeObject(LLViewerObject *object)
 {
+//MK
+	// We first need to check whether the object is locked, as some techniques (like llAttachToAvatar)
+	// can kick even a locked attachment off.
+	// If so, retain its UUID for later
+	if (RRenabled && object && object->getRootEdit()
+		&& !gAgent.mRRInterface.isAllowed(object->getRootEdit()->getID(), "detach"))
+	{
+		llinfos << "Detached a locked object : " << mItemID << llendl;
+		gAgent.mRRInterface.sAssetToReattach = mItemID;
+	}
+//mk
 	// force object visibile
 	setAttachmentVisibility(TRUE);
 
diff -urN linden/indra/newview/llviewermenu.cpp linden-patched/indra/newview/llviewermenu.cpp
--- linden/indra/newview/llviewermenu.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/llviewermenu.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -235,6 +235,9 @@
 extern BOOL gShowOverlayTitle;
 extern BOOL gOcclusionCull;
 extern BOOL gAllowSelectAvatar;
+//MK
+extern BOOL RRenabled;
+//mk
 
 //
 // Globals
@@ -951,12 +954,16 @@
 										(void*)"SaveMinidump"));
 
 	// TomY Temporary menu item so we can test this floater
-	menu->append(new LLMenuItemCheckGL("Clothing...", 
+//MK
+	if (!RRenabled)
+	{
+//mk
+		menu->append(new LLMenuItemCheckGL("Clothing...", 
 												&handle_clothing,
 												NULL,
 												NULL,
 												NULL));
-
+	}
 	menu->append(new LLMenuItemCallGL("Debug Settings...", LLFloaterSettingsDebug::show, NULL, NULL));
 	menu->append(new LLMenuItemCheckGL("View Admin Options", &handle_admin_override_toggle, NULL, &check_admin_override, NULL, 'V', MASK_CONTROL | MASK_ALT));
 
@@ -1523,6 +1530,19 @@
 
 		LLPickInfo pick = LLToolPie::getInstance()->getPick();
 
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsFartouch)
+		{
+//			LLVector3 pos = object->getPositionRegion ();
+			LLVector3 pos = pick.mIntersection;
+			pos -= gAgent.getPositionAgent ();
+			if (pos.magVec () >= 1.5)
+			{
+				return true;
+			}
+		}
+//mk
+
 		LLMessageSystem	*msg = gMessageSystem;
 
 		msg->newMessageFast(_PREHASH_ObjectGrab);
@@ -1605,6 +1625,18 @@
 {
 	LLViewerObject* obj = LLSelectMgr::getInstance()->getSelection()->getPrimaryObject();
 	if(!obj) return true;
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsFartouch)
+	{
+//		LLVector3 pos = obj->getPositionRegion ();
+		LLVector3 pos = LLToolPie::getInstance()->getPick().mIntersection;
+		pos -= gAgent.getPositionAgent ();
+		if (pos.magVec () >= 1.5)
+		{
+			return true;
+		}
+	}
+//mk
 
 	LLFloaterOpenObject::show();
 	return true;
@@ -1614,6 +1646,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("edit"))
+		{
+			return true;
+		}
+//mk
 		return handle_object_open();
 	}
 };
@@ -1628,6 +1666,18 @@
 		bool new_value = (obj != NULL);
 		if (new_value)
 		{
+//MK
+			if (RRenabled && gAgent.mRRInterface.mContainsFartouch)
+			{
+//				LLVector3 pos = obj->getPositionRegion ();
+				LLVector3 pos = LLToolPie::getInstance()->getPick().mIntersection;
+				pos -= gAgent.getPositionAgent ();
+				if (pos.magVec () >= 1.5)
+				{
+					return true;
+				}
+			}
+//mk
 			LLViewerObject* root = obj->getRootEdit();
 			if (!root) new_value = false;
 			else new_value = root->allowOpen();
@@ -1669,6 +1719,12 @@
 	}
 	else
 	{
+//MK
+		if (RRenabled && (gAgent.mRRInterface.contains ("rez") || gAgent.mRRInterface.contains ("edit")))
+		{
+			return false;
+		}
+//mk
 		ECameraMode camMode = gAgent.getCameraMode();
 		if (CAMERA_MODE_MOUSELOOK == camMode ||	CAMERA_MODE_CUSTOMIZE_AVATAR == camMode)
 		{
@@ -1764,6 +1820,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && (gAgent.mRRInterface.contains ("rez") || gAgent.mRRInterface.contains ("edit")))
+		{
+			return false;
+		}
+//mk
 		if (gAgent.getFocusOnAvatar() && !LLToolMgr::getInstance()->inEdit() && gSavedSettings.getBOOL("EditCameraMovement") )
 		{
 			// zoom in if we're looking at the avatar
@@ -1792,6 +1854,27 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("edit"))
+		{
+			return false;
+		}
+
+		if (RRenabled && gAgent.mRRInterface.mContainsFartouch
+			&& LLSelectMgr::getInstance()->getSelection()->getFirstObject()
+//			&& LLSelectMgr::getInstance()->getSelection()->getSelectType() != SELECT_TYPE_HUD
+			&& !LLSelectMgr::getInstance()->getSelection()->getFirstObject()->isHUDAttachment()
+			)
+		{
+//			LLVector3 pos = LLSelectMgr::getInstance()->getSelection()->getFirstObject()->getPositionRegion ();
+			LLVector3 pos = LLToolPie::getInstance()->getPick().mIntersection;
+			pos -= gAgent.getPositionAgent ();
+			if (pos.magVec () >= 1.5)
+			{
+				return false;
+			}
+		}
+//mk
 		LLViewerParcelMgr::getInstance()->deselectLand();
 
 		if (gAgent.getFocusOnAvatar() && !LLToolMgr::getInstance()->inEdit())
@@ -1811,14 +1894,14 @@
 				LLViewerObject* selected_objectp = selection->getFirstRootObject();
 				if (selected_objectp)
 				{
-				// zoom in on object center instead of where we clicked, as we need to see the manipulator handles
+					// zoom in on object center instead of where we clicked, as we need to see the manipulator handles
 					gAgent.setFocusGlobal(selected_objectp->getPositionGlobal(), selected_objectp->getID());
-				gAgent.cameraZoomIn(0.666f);
-				gAgent.cameraOrbitOver( 30.f * DEG_TO_RAD );
-				gViewerWindow->moveCursorToCenter();
+					gAgent.cameraZoomIn(0.666f);
+					gAgent.cameraOrbitOver( 30.f * DEG_TO_RAD );
+					gViewerWindow->moveCursorToCenter();
+				}
 			}
 		}
-		}
 
 		gFloaterTools->open();		/* Flawfinder: ignore */
 	
@@ -1838,6 +1921,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+		{
+			return false;
+		}
+//mk
 		LLFloaterInspect::show();
 		return true;
 	}
@@ -1952,6 +2041,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsDetach)
+		{
+			return false;
+		}
+//mk
 		LLAgent::userRemoveAllAttachments(NULL);
 		return true;
 	}
@@ -1961,6 +2056,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsDetach)
+		{
+			return false;
+		}
+//mk
 		bool new_value = false;
 		if (gAgent.getAvatarObject())
 		{
@@ -2005,6 +2106,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+		{
+			return false;
+		}
+//mk
 		LLViewerObject* object = LLSelectMgr::getInstance()->getSelection()->getPrimaryObject();
 		bool new_value = (object != NULL);
 		if (new_value)
@@ -2037,6 +2144,12 @@
 		LLVOAvatar* avatar = find_avatar_from_object(object); 
 		if (avatar)
 		{
+//MK
+			if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+			{
+				return false;
+			}
+//mk
 			id = avatar->getID();
 
 			LLNameValue *firstname = avatar->getNVPair("FirstName");
@@ -2081,6 +2194,12 @@
 
 bool handle_go_to()
 {
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsDetach)
+	{
+		return true;
+	}
+//mk
 	// JAMESDEBUG try simulator autopilot
 	std::vector<std::string> strings;
 	std::string val;
@@ -2163,7 +2282,12 @@
 		{
 			LLUUID* avatar_id = new LLUUID( avatar->getID() );
 			std::string fullname = avatar->getFullname();
-
+//MK
+			if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+			{
+				fullname = gAgent.mRRInterface.getDummyName (fullname);
+			}
+//mk
 			if (!fullname.empty())
 			{
 				LLStringUtil::format_map_t args;
@@ -2188,6 +2312,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+		{
+			return false;
+		}
+//mk
 		bool new_value = gAgent.isGodlike();
 		gMenuHolder->findControl(userdata["control"].asString())->setValue(new_value);
 		return true;
@@ -2198,6 +2328,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+		{
+			return false;
+		}
+//mk
 		bool new_value = gAgent.isGodlike();
 		gMenuHolder->findControl(userdata["control"].asString())->setValue(new_value);
 		return true;
@@ -2208,6 +2344,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+		{
+			return false;
+		}
+//mk
 		LLVOAvatar* avatar = find_avatar_from_object( LLSelectMgr::getInstance()->getSelection()->getPrimaryObject() );
 		if( avatar )
 		{
@@ -2300,7 +2442,12 @@
 			MenuCallbackData *data = new MenuCallbackData;
 			(*data).avatar_id = avatar->getID();
 			std::string fullname = avatar->getFullname();
-
+//MK
+			if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+			{
+				fullname = gAgent.mRRInterface.getDummyName (fullname);
+			}
+//mk
 			const LLVector3d& pos = avatar->getPositionGlobal();
 			LLParcel* parcel = LLViewerParcelMgr::getInstance()->selectParcelAt(pos)->getParcel();
 			
@@ -2381,6 +2528,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+		{
+			return false;
+		}
+//mk
 		llinfos << "handle_give_card()" << llendl;
 		LLViewerObject* dest = LLSelectMgr::getInstance()->getSelection()->getPrimaryObject();
 		if(dest && dest->isAvatar())
@@ -2630,6 +2783,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsUnsit)
+		{
+			return true;
+		}
+//mk
 		gAgent.setControlFlags(AGENT_CONTROL_STAND_UP);
 		return true;
 	}
@@ -2812,6 +2971,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+		{
+			return false;
+		}
+//mk
 		LLVOAvatar* avatar = find_avatar_from_object(LLSelectMgr::getInstance()->getSelection()->getPrimaryObject());
 		bool new_value = avatar && !is_agent_friend(avatar->getID());
 		gMenuHolder->findControl(userdata["control"].asString())->setValue(new_value);
@@ -2872,6 +3037,17 @@
 		return true;
 	}
 
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsUnsit)
+	{
+		if (gAgent.getAvatarObject() &&
+			gAgent.getAvatarObject()->mIsSitting)
+		{
+			return true;
+		}
+	}
+//mk
+
 	if (sitting_on_selection())
 	{
 		gAgent.setControlFlags(AGENT_CONTROL_STAND_UP);
@@ -2882,6 +3058,18 @@
 
 	if (object && object->getPCode() == LL_PCODE_VOLUME)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("sittp")
+			|| gAgent.mRRInterface.mContainsFartouch)
+		{
+			LLVector3 pos = object->getPositionRegion() + pick.mObjectOffset;
+			pos -= gAgent.getPositionAgent ();
+			if (pos.magVec () >= 1.5)
+			{
+				return true;
+			}
+		}
+//mk
 		gMessageSystem->newMessageFast(_PREHASH_AgentRequestSit);
 		gMessageSystem->nextBlockFast(_PREHASH_AgentData);
 		gMessageSystem->addUUIDFast(_PREHASH_AgentID, gAgent.getID());
@@ -2919,6 +3107,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsUnsit)
+		{
+			return true;
+		}
+//mk
 		gAgent.setControlFlags(AGENT_CONTROL_STAND_UP);
 		LLViewerParcelMgr::getInstance()->deselectLand();
 
@@ -3653,6 +3847,23 @@
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
 		if (LLSelectMgr::getInstance()->getSelection()->isEmpty()) return true;
+
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("rez"))
+		{
+			return false;
+		}
+
+		if (RRenabled && gAgent.mRRInterface.mContainsUnsit
+			&& gAgent.getAvatarObject()
+			&& gAgent.getAvatarObject()->mIsSitting
+			&& LLSelectMgr::getInstance()->getSelection()
+			&& LLSelectMgr::getInstance()->getSelection()->getFirstObject()
+			&& LLSelectMgr::getInstance()->getSelection()->getFirstObject()->isSeat())
+		{
+			return false;
+		}
+//mk
 		
 		mObjectSelection = LLSelectMgr::getInstance()->getEditSelection();
 
@@ -3690,6 +3901,22 @@
 #ifdef HACKED_GODLIKE_VIEWER
 		bool new_value = true;
 #else
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("rez"))
+		{
+			return false;
+		}
+
+		if (RRenabled && gAgent.mRRInterface.mContainsUnsit
+			&& gAgent.getAvatarObject()
+			&& gAgent.getAvatarObject()->mIsSitting
+			&& LLSelectMgr::getInstance()->getSelection()
+			&& LLSelectMgr::getInstance()->getSelection()->getFirstObject()
+			&& LLSelectMgr::getInstance()->getSelection()->getFirstObject()->isSeat())
+		{
+			return false;
+		}
+//mk
 		bool new_value = false;
 		if (gAgent.isGodlike())
 		{
@@ -3711,6 +3938,12 @@
 					{
 						virtual bool apply(LLViewerObject* obj)
 						{
+//MK
+							if (RRenabled && obj->isSeat() && gAgent.mRRInterface.mContainsUnsit)
+							{
+								return false;
+							}
+//mk
 							return (obj->isOverAgentOwnedLand() ||
 									obj->isOverGroupOwnedLand() ||
 									obj->permModify());
@@ -3742,7 +3975,22 @@
 	{
 		return;
 	}
-	
+//MK
+	if (RRenabled && gAgent.mRRInterface.contains ("rez"))
+	{
+		return;
+	}
+
+	if (RRenabled && gAgent.mRRInterface.mContainsUnsit
+		&& gAgent.getAvatarObject()
+		&& gAgent.getAvatarObject()->mIsSitting
+		&& LLSelectMgr::getInstance()->getSelection()
+		&& LLSelectMgr::getInstance()->getSelection()->getFirstObject()
+		&& LLSelectMgr::getInstance()->getSelection()->getFirstObject()->isSeat())
+	{
+		return;
+	}
+//mk
 	BOOL you_own_everything = TRUE;
 	BOOL locked_but_takeable_object = FALSE;
 	LLUUID category_id;
@@ -3863,7 +4111,12 @@
 	{
 		return FALSE;
 	}
-
+//MK
+	if (RRenabled && gAgent.mRRInterface.contains ("rez"))
+	{
+		return FALSE;
+	}
+//mk
 	for (LLObjectSelection::valid_root_iterator iter = LLSelectMgr::getInstance()->getSelection()->valid_root_begin();
 		 iter != LLSelectMgr::getInstance()->getSelection()->valid_root_end(); iter++)
 	{
@@ -4277,6 +4530,17 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsUnsit
+			&& gAgent.getAvatarObject()
+			&& gAgent.getAvatarObject()->mIsSitting
+			&& LLSelectMgr::getInstance()->getSelection()
+			&& LLSelectMgr::getInstance()->getSelection()->getFirstObject()
+			&& LLSelectMgr::getInstance()->getSelection()->getFirstObject()->isSeat())
+		{
+			return true;
+		}
+//mk
 		LLSelectMgr::getInstance()->sendDelink();
 		return true;
 	}
@@ -4301,6 +4565,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsDetach)
+		{
+			return false;
+		}
+//mk
 		gAgent.forceReleaseControls();
 
 		return true;
@@ -4419,6 +4689,12 @@
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
 		bool new_value = LLEditMenuHandler::gEditMenuHandler && LLEditMenuHandler::gEditMenuHandler->canDoDelete();
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("rez"))
+		{
+			new_value = false;
+		}
+//mk
 		gMenuHolder->findControl(userdata["control"].asString())->setValue(new_value);
 		return true;
 	}
@@ -4459,6 +4735,12 @@
 # endif
 			LLSelectMgr::getInstance()->canDoDelete();
 #endif
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("rez"))
+		{
+			new_value = false;
+		}
+//mk
 		gMenuHolder->findControl(userdata["control"].asString())->setValue(new_value);
 		return true;
 	}
@@ -4823,6 +5105,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+		{
+			return true;
+		}
+//mk
 		LLViewerRegion* agent_region = gAgent.getRegion();
 		if(!agent_region)
 		{
@@ -4923,6 +5211,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+		{
+			return false;
+		}
+//mk
 		LLVOAvatar* avatar = find_avatar_from_object( LLSelectMgr::getInstance()->getSelection()->getPrimaryObject() );
 		if(avatar)
 		{
@@ -4936,6 +5230,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+		{
+			return false;
+		}
+//mk
 		LLVOAvatar* avatar = find_avatar_from_object( LLSelectMgr::getInstance()->getSelection()->getPrimaryObject() );
 		if(avatar && !is_agent_friend(avatar->getID()))
 		{
@@ -4970,6 +5270,12 @@
 	{
 		if (objectp->isAvatar())
 		{
+//MK
+			if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+			{
+				return;
+			}
+//mk
 			const BOOL is_group = FALSE;
 			LLFloaterPay::payDirectly(&give_money,
 									  objectp->getID(),
@@ -5207,7 +5513,12 @@
 				LLViewerParcelMgr::getInstance()->selectParcelAt(gAgent.getPositionGlobal());
 			}
 
-			LLFloaterLand::showInstance();
+//MK
+			if (!RRenabled || !gAgent.mRRInterface.mContainsShowloc)
+			{
+//mk
+				LLFloaterLand::showInstance();
+			}
 		}
 		else if (floater_name == "buy land")
 		{
@@ -5216,11 +5527,21 @@
 				LLViewerParcelMgr::getInstance()->selectParcelAt(gAgent.getPositionGlobal());
 			}
 			
-			LLViewerParcelMgr::getInstance()->startBuyLand();
+//MK
+			if (!RRenabled || !gAgent.mRRInterface.mContainsShowloc)
+			{
+//mk
+				LLViewerParcelMgr::getInstance()->startBuyLand();
+			}
 		}
 		else if (floater_name == "about region")
 		{
-			LLFloaterRegionInfo::showInstance();
+//MK
+			if (!RRenabled || !gAgent.mRRInterface.mContainsShowloc)
+			{
+//mk
+				LLFloaterRegionInfo::showInstance();
+			}
 		}
 		else if (floater_name == "grid options")
 		{
@@ -5384,6 +5705,12 @@
 		}
 		else if (userdata.asString() == "hit object")
 		{
+//MK
+			if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+			{
+				return false;
+			}
+//mk
 			LLViewerObject* objectp = LLSelectMgr::getInstance()->getSelection()->getPrimaryObject();
 			if (objectp)
 			{
@@ -5443,6 +5770,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("edit"))
+		{
+			return false;
+		}
+//mk
 		if (gAgent.getFocusOnAvatar() && gSavedSettings.getBOOL("EditCameraMovement") )
 		{
 			// zoom in if we're looking at the avatar
@@ -5520,6 +5853,12 @@
 private:
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("rez"))
+		{
+			return false; // we can't take objects when unable to rez
+		}
+//mk
 		setObjectSelection(LLSelectMgr::getInstance()->getSelection());
 		LLViewerObject* selectedObject = sObjectSelection->getFirstRootObject();
 		if (selectedObject)
@@ -5528,6 +5867,27 @@
 			LLViewerJointAttachment* attachment_point = NULL;
 			if (index > 0)
 				attachment_point = get_if_there(gAgent.getAvatarObject()->mAttachmentPoints, index, (LLViewerJointAttachment*)NULL);
+//MK
+			if (RRenabled)
+			{
+				if (index == 0 && gAgent.mRRInterface.mContainsDetach)
+				{
+					setObjectSelection (NULL);
+					return false; // something is locked and we're attempting a Wear in-world
+				}
+				LLUUID uuid;
+				if (attachment_point)
+				{
+					LLViewerObject* attached_object = attachment_point->getObject();
+					if (attachment_point && attached_object) uuid = attached_object->getRootEdit()->getID();
+					if (!uuid.isNull() && !gAgent.mRRInterface.isAllowed (uuid, "detach"))
+					{
+						setObjectSelection (NULL);
+						return false;
+					}
+				}
+			}
+//mk
 			confirm_replace_attachment(0, attachment_point);
 		}
 		return true;
@@ -5653,6 +6013,12 @@
 
 	if (attached_object)
 	{
+//MK
+		if (RRenabled && !gAgent.mRRInterface.isAllowed (attached_object->getID(), "detach"))
+		{
+			return;
+		}
+//mk
 		gMessageSystem->newMessage("ObjectDetach");
 		gMessageSystem->nextBlockFast(_PREHASH_AgentData);
 		gMessageSystem->addUUIDFast(_PREHASH_AgentID, gAgent.getID() );
@@ -5711,7 +6077,12 @@
 			llwarns << "handle_detach() - no object to detach" << llendl;
 			return true;
 		}
-
+//MK
+		if (RRenabled && !gAgent.mRRInterface.isAllowed (object->getID(), "detach"))
+		{
+			return true;
+		}
+//mk
 		LLViewerObject *parent = (LLViewerObject*)object->getParent();
 		while (parent)
 		{
@@ -5820,6 +6191,12 @@
 		//now check to make sure that the item is actually in the inventory before we enable dropping it
 		bool new_value = enable_detach(NULL) && can_build && item;
 
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("rez"))
+		{
+			new_value = false;
+		}
+//mk
 		gMenuHolder->findControl(userdata["control"].asString())->setValue(new_value);
 		return true;
 	}
@@ -5831,6 +6208,19 @@
 	if (!object) return FALSE;
 	if (!object->isAttachment()) return FALSE;
 
+//MK
+	if (RRenabled && !gAgent.mRRInterface.isAllowed(object->getRootEdit()->getID(), "detach"))
+	{
+		return FALSE;
+	}
+
+	// prevent a clever workaround that allowed to detach several objects at the same time by selecting them
+	if (RRenabled && gAgent.mRRInterface.mContainsDetach && LLSelectMgr::getInstance()->getSelection()->getRootObjectCount() > 1)
+	{
+		return FALSE;
+	}
+//mk
+
 	// Find the avatar who owns this attachment
 	LLViewerObject* avatar = object;
 	while (avatar)
@@ -5916,6 +6306,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsDetach)
+		{
+			return false;
+		}
+//mk
 		bool is_wearable = object_selected_and_point_valid(NULL);
 		gMenuHolder->findControl(userdata["control"].asString())->setValue(is_wearable);
 		return TRUE;
@@ -5934,6 +6330,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+		{
+			return false;
+		}
+//mk
 		LLVOAvatar* avatar = find_avatar_from_object( LLSelectMgr::getInstance()->getSelection()->getPrimaryObject() );
 		if(avatar)
 		{
@@ -6061,6 +6463,12 @@
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
 		std::string action = userdata.asString();
+//MK
+		if (RRenabled && !gAgent.mRRInterface.isAllowed (LLSelectMgr::getInstance()->getSelection()->getFirstObject()->getRootEdit()->getID(), "detach"))
+		{
+			return true;
+		}
+//mk
 		if (action == "compile mono")
 		{
 			handle_compile_queue("mono");
@@ -6141,12 +6549,28 @@
 
 void handle_test_male(void*)
 {
+//MK
+	if (RRenabled && (gAgent.mRRInterface.mContainsDetach ||
+		gAgent.mRRInterface.contains ("remoutfit") ||
+		gAgent.mRRInterface.contains ("addoutfit")))
+	{
+		return;
+	}
+//mk
 	wear_outfit_by_name("Male Shape & Outfit");
 	//gGestureList.requestResetFromServer( TRUE );
 }
 
 void handle_test_female(void*)
 {
+//MK
+	if (RRenabled && (gAgent.mRRInterface.mContainsDetach ||
+		gAgent.mRRInterface.contains ("remoutfit") ||
+		gAgent.mRRInterface.contains ("addoutfit")))
+	{
+		return;
+	}
+//mk
 	wear_outfit_by_name("Female Shape & Outfit");
 	//gGestureList.requestResetFromServer( FALSE );
 }
@@ -6169,6 +6593,13 @@
 		return;
 	}
 
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsDetach)
+	{
+		return;
+	}
+//mk
+
 	for (LLVOAvatar::attachment_map_t::iterator iter = avatar->mAttachmentPoints.begin(); 
 		 iter != avatar->mAttachmentPoints.end(); )
 	{
@@ -6345,6 +6776,12 @@
 				{
 					virtual bool apply(LLViewerObject* obj)
 					{
+//MK
+						if (RRenabled && obj->isSeat ()  && gAgent.mRRInterface.mContainsUnsit)
+						{
+							return true;
+						}
+//mk
 						return (!obj->permCopy() || obj->isAttachment());
 					}
 				} func;
@@ -6546,6 +6983,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+		{
+			return false;
+		}
+//mk
 		bool new_value = gAgent.isGodlike() || 
 			(gAgent.getRegion() && gAgent.getRegion()->getAllowLandmark());
 		gMenuHolder->findControl(userdata["control"].asString())->setValue(new_value);
@@ -7093,6 +7536,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("edit"))
+		{
+			return true;
+		}
+//mk
 		LLDrawPoolAlpha::sShowDebugAlpha = !LLDrawPoolAlpha::sShowDebugAlpha;
 		return true;
 	}
@@ -7103,6 +7552,12 @@
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
 		bool new_value = LLDrawPoolAlpha::sShowDebugAlpha;
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("edit"))
+		{
+			new_value = false;
+		}
+//mk
 		gMenuHolder->findControl(userdata["control"].asString())->setValue(new_value);
 		return true;
 	}
@@ -7140,6 +7595,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsDetach)
+		{
+			return false;
+		}
+//mk
 		LLPipeline::sShowHUDAttachments = !LLPipeline::sShowHUDAttachments;
 		return true;
 	}
@@ -7149,6 +7610,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsDetach)
+		{
+			return false;
+		}
+//mk
 		bool new_value = LLPipeline::sShowHUDAttachments;
 		gMenuHolder->findControl(userdata["control"].asString())->setValue(new_value);
 		return true;
@@ -7162,6 +7629,14 @@
 		std::string control_name = userdata["control"].asString();
 		std::string clothing = userdata["data"].asString();
 		bool new_value = false;
+//MK
+		if (RRenabled && (
+			   gAgent.mRRInterface.contains ("remoutfit")
+			|| gAgent.mRRInterface.contains ("remoutfit:" + clothing) ) )
+		{
+			return false;
+		}
+//mk
 		if (clothing == "shirt")
 		{
 			new_value = LLAgent::selfHasWearable((void *)WT_SHIRT);
@@ -7265,6 +7740,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("edit"))
+		{
+			return true;
+		}
+//mk
 		std::string tool_name = userdata.asString();
 		if (tool_name == "focus")
 		{
@@ -7295,6 +7776,12 @@
 {	
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsSetenv)
+		{
+			return true;
+		}
+//mk
 		std::string tod = userdata.asString();
 		LLVector3 sun_direction;
 		
@@ -7372,6 +7859,12 @@
 {	
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsSetenv)
+		{
+			return true;
+		}
+//mk
 		// if not there or is hidden, show it
 		if(	!LLFloaterWater::isOpen() || 
 			!LLFloaterWater::instance()->getVisible()) {
@@ -7392,6 +7885,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsSetenv)
+		{
+			return true;
+		}
+//mk
 		LLFloaterPostProcess::show();
 		return true;
 	}
@@ -7402,6 +7901,12 @@
 {
 	bool handleEvent(LLPointer<LLEvent> event, const LLSD& userdata)
 	{
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsSetenv)
+		{
+			return true;
+		}
+//mk
 		LLFloaterDayCycle::show();
 		return true;
 	}
diff -urN linden/indra/newview/llviewermessage.cpp linden-patched/indra/newview/llviewermessage.cpp
--- linden/indra/newview/llviewermessage.cpp	2009-03-11 18:46:02.000000000 +0100
+++ linden-patched/indra/newview/llviewermessage.cpp	2009-03-16 21:03:27.000000000 +0100
@@ -141,6 +141,10 @@
 #include "llwindebug.h"	// For the invalid message handler
 #endif
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 //
 // Constants
 //
@@ -1025,6 +1029,19 @@
 	
 	bool busy=FALSE;
 	
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		std::string str (info->mDesc.c_str());
+
+		// hide every occurrence of the Parcel name if the location restriction is active
+		str = gAgent.mRRInterface.stringReplace (str, gAgent.mRRInterface.getParcelName(), "(Parcel hidden)");
+		// hide every occurrence of the Region name if the location restriction is active
+		str = gAgent.mRRInterface.stringReplace (str, gAgent.getRegion()->getName(), "(Region hidden)");
+		info->mDesc = str;
+	}
+//mk
+	
 	switch(button)
 	{
 	case IOR_ACCEPT:
@@ -1043,7 +1060,7 @@
 		if (check_offer_throttle(info->mFromName, true))
 		{
 			log_message = chatHistory_string + " gave you " + info->mDesc + ".";
- 			chat.mText = log_message;
+			chat.mText = log_message;
  			LLFloaterChat::addChatHistory(chat);
 		}
 
@@ -1396,6 +1413,21 @@
 		// These are used for system messages, hence don't need the name,
 		// as it is always "Second Life".
 	  	// *TODO:translate
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+		{
+			// hide every occurrence of the Parcel name if the location restriction is active
+			message = gAgent.mRRInterface.stringReplace (message, gAgent.mRRInterface.getParcelName(), "(Parcel hidden)");
+			// hide every occurrence of the Region name if the location restriction is active
+			message = gAgent.mRRInterface.stringReplace (message, gAgent.getRegion()->getName(), "(Region hidden)");
+		}
+
+		if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+		{
+			// censor object IMs but not avatar IMs
+			message = gAgent.mRRInterface.getCensoredMessage (message);
+		}
+//mk
 		args["[MESSAGE]"] = message;
 
 		// Note: don't put the message in the IM history, even though was sent
@@ -1412,11 +1444,16 @@
 			// do nothing -- don't distract newbies in
 			// Prelude with global IMs
 		}
-		else if (offline == IM_ONLINE && !is_linden && is_busy && name != SYSTEM_FROM)
+		else if (offline == IM_ONLINE && !is_linden && is_busy && name != SYSTEM_FROM
+//MK
+			 // agent is not forbidden to receive IMs or the sender is an exception => send Busy response
+			&& (!RRenabled || (!gAgent.mRRInterface.contains ("recvim") ||
+				gAgent.mRRInterface.contains ("recvim:"+from_id.asString ()))))
+//mk
 		{
 			// return a standard "busy" message, but only do it to online IM 
 			// (i.e. not other auto responses and not store-and-forward IM)
-			if (!gIMMgr->hasSession(session_id))
+			if (RRenabled || !gIMMgr->hasSession(session_id))
 			{
 				// if there is not a panel for this conversation (i.e. it is a new IM conversation
 				// initiated by the other party) then...
@@ -1460,11 +1497,66 @@
 			chat.mText = std::string("IM: ") + name + separator_string + message.substr(message_offset);
 			LLFloaterChat::addChat( chat, TRUE, TRUE );
 		}
+//MK
+		else if (RRenabled && message == "@version")
+		{
+			// return the version message
+			std::string my_name;
+			gAgent.buildFullname(my_name);
+			std::string response = gAgent.mRRInterface.getVersion ();
+			pack_instant_message(
+				gMessageSystem,
+				gAgent.getID(),
+				FALSE,
+				gAgent.getSessionID(),
+				from_id,
+				my_name.c_str(),
+				response.c_str(),
+				IM_ONLINE,
+				IM_BUSY_AUTO_RESPONSE,
+				session_id);
+			gAgent.sendReliableMessage();
+
+			// remove the "XXX is typing..." label from the IM window
+			LLPointer<LLIMInfo> im_info = new LLIMInfo(gMessageSystem);
+			gIMMgr->processIMTypingStop(im_info);
+
+			//// now store incoming IM in chat history
+
+			//snprintf(buffer, sizeof(buffer), "%s%s%s", name, separator_string, (message+message_offset));		/* Flawfinder: ignore */
+	
+			//llinfos << "process_improved_im: session_id( " << session_id << " ), from_id( " << from_id << " )" << llendl;
+
+			//// add to IM panel, but do not bother the user
+			//gIMMgr->addMessage(
+			//	session_id,
+			//	from_id,
+			//	name,
+			//	buffer,
+			//	NULL,
+			//	dialog,
+			//	parent_estate_id,
+			//	region_id,
+			//	position);
+
+			//// pretend this is chat generated by self, so it does not show up on screen
+			//snprintf(buffer, sizeof(buffer), "IM: %s%s%s", name, separator_string, (message+message_offset));		/* Flawfinder: ignore */
+			//chat.mText = buffer;
+			//LLFloaterChat::addChat( chat, TRUE, TRUE );
+		}
+//mk
 		else if (from_id.isNull())
 		{
 			// Messages from "Second Life" ID don't go to IM history
 			// messages which should be routed to IM window come from a user ID with name=SYSTEM_NAME
 			chat.mText = name + ": " + message;
+//MK
+			if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+			{
+				// censor that message
+				chat.mText = gAgent.mRRInterface.getCensoredMessage(chat.mText);
+			}
+//mk
 			LLFloaterChat::addChat(chat, FALSE, FALSE);
 		}
 		else if (to_id.isNull())
@@ -1491,6 +1583,36 @@
 			}
 			buffer = separator_string + saved  + message.substr(message_offset);
 
+//MK
+			if (RRenabled && gAgent.mRRInterface.contains ("recvim"))
+			{
+				// agent is forbidden to receive IMs
+				if (!gAgent.mRRInterface.contains ("recvim:"+from_id.asString ()))
+				{
+					// and the sender is no exception
+					buffer = separator_string + saved + "*** IM blocked by your viewer";
+					
+					// tell the sender the avatar could not read them
+					std::string my_name;
+					gAgent.buildFullname(my_name);
+					my_name = my_name+" using viewer "+gAgent.mRRInterface.getVersion ();
+					std::string response = "The Resident you messaged is prevented from reading your instant messages at the moment, please try again later.";
+					pack_instant_message(
+						gMessageSystem,
+						gAgent.getID(),
+						FALSE,
+						gAgent.getSessionID(),
+						from_id,
+						my_name.c_str(),
+						response.c_str(),
+						IM_ONLINE,
+						IM_BUSY_AUTO_RESPONSE,
+						session_id);
+					gAgent.sendReliableMessage();
+				}
+			}
+//mk
+
 			LL_INFOS("Messaging") << "process_improved_im: session_id( " << session_id << " ), from_id( " << from_id << " )" << LL_ENDL;
 
 			if (!is_muted || is_linden)
@@ -1506,7 +1628,15 @@
 					region_id,
 					position,
 					true);
-				chat.mText = std::string("IM: ") + name + separator_string + saved + message.substr(message_offset);
+//MK
+				 // RR disabled, or agent is not forbidden to receive IMs,
+				 // or the sender is an exception => duplicate in chat box
+				if (!RRenabled || !gAgent.mRRInterface.contains ("recvim") ||
+					gAgent.mRRInterface.contains ("recvim:"+from_id.asString ()))
+				{
+//mk
+					chat.mText = std::string("IM: ") + name + separator_string + saved + message.substr(message_offset);
+				}
 
 				BOOL local_agent = FALSE;
 				LLFloaterChat::addChat( chat, TRUE, local_agent );
@@ -1541,6 +1671,20 @@
 		{
 			// This is a block, modeless dialog.
 			//*TODO:translate
+//MK
+			if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+			{
+				// hide every occurrence of the Parcel name if the location restriction is active
+				message = gAgent.mRRInterface.stringReplace (message, gAgent.mRRInterface.getParcelName(), "(Parcel hidden)");
+				// hide every occurrence of the Region name if the location restriction is active
+				message = gAgent.mRRInterface.stringReplace (message, gAgent.getRegion()->getName(), "(Region hidden)");
+			}
+			
+			if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+			{
+				message = gAgent.mRRInterface.getCensoredMessage(message);
+			}
+//mk
 			args["[MESSAGE]"] = message;
 			LLNotifyBox::showXml("SystemMessage", args);
 		}
@@ -1705,7 +1849,22 @@
 			info->mFromID = from_id;
 			info->mFromGroup = from_group;
 			info->mTransactionID = session_id;
-			info->mFolderID = gInventory.findCategoryUUIDForType(info->mType);
+//MK
+			std::string folder_name(message);
+			if (RRenabled && gSavedSettings.getBOOL("RestrainedLifeAllowPutInv") &&
+				gAgent.mRRInterface.contains("putinv:" + info->mFromID.asString()) &&
+				info->mType == LLAssetType::AT_CATEGORY &&
+				folder_name.find(RR_SHARED_FOLDER_WITH_SEPARATOR) == 1)
+			{
+				info->mFolderID = gAgent.mRRInterface.getRlvShare()->getUUID();
+			}
+			else
+			{
+//mk
+				info->mFolderID = gInventory.findCategoryUUIDForType(info->mType);
+//MK
+			}
+//mk
 
 			if (dialog == IM_TASK_INVENTORY_OFFERED)
 			{
@@ -1716,6 +1875,15 @@
 				info->mFromObject = FALSE;
 			}
 			info->mFromName = name;
+//MK
+			if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+			{
+				// hide every occurrence of the Parcel name if the location restriction is active
+				message = gAgent.mRRInterface.stringReplace (message, gAgent.mRRInterface.getParcelName(), "(Parcel hidden)");
+				// hide every occurrence of the Region name if the location restriction is active
+				message = gAgent.mRRInterface.stringReplace (message, gAgent.getRegion()->getName(), "(Region hidden)");
+			}
+//mk
 			info->mDesc = message;
 			info->mHost = msg->getSender();
 			//if (((is_busy && !is_owned_by_me) || is_muted))
@@ -1724,6 +1892,15 @@
 				// Same as closing window
 				inventory_offer_callback(-1, info);
 			}
+//MK
+			else if (RRenabled && gSavedSettings.getBOOL("RestrainedLifeAllowPutInv") &&
+				gAgent.mRRInterface.contains("putinv:" + info->mFromID.asString()) &&
+				info->mType == LLAssetType::AT_CATEGORY &&
+				folder_name.find(RR_SHARED_FOLDER_WITH_SEPARATOR) == 1)
+			{
+				inventory_offer_callback(IOR_ACCEPT, info);
+			}
+//mk
 			else
 			{
 				inventory_offer_handler(info, dialog == IM_TASK_INVENTORY_OFFERED);
@@ -1765,7 +1942,13 @@
 		{
 			return;
 		}
-
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("recvim"))
+		{
+			 // agent is forbidden to receive IMs
+			return;
+		}
+//mk
 		// Only show messages if we have a session open (which
 		// should happen after you get an "invitation"
 		if ( !gIMMgr->hasSession(session_id) )
@@ -1807,6 +1990,20 @@
 		{
 			return;
 		}
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+		{
+			// hide every occurrence of the Parcel name if the location restriction is active
+			message = gAgent.mRRInterface.stringReplace (message, gAgent.mRRInterface.getParcelName(), "(Parcel hidden)");
+			// hide every occurrence of the Region name if the location restriction is active
+			message = gAgent.mRRInterface.stringReplace (message, gAgent.getRegion()->getName(), "(Region hidden)");
+		}
+			
+		if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+		{
+			message = gAgent.mRRInterface.getCensoredMessage(message);
+		}
+//mk
 		chat.mText = name + separator_string + message.substr(message_offset);
 		// Note: lie to LLFloaterChat::addChat(), pretending that this is NOT an IM, because
 		// IMs from objcts don't open IM sessions.
@@ -1820,6 +2017,21 @@
 		}
 		{
 			// Construct a viewer alert for this message.
+//MK
+			if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+			{
+				// hide every occurrence of the Parcel name if the location restriction is active
+				message = gAgent.mRRInterface.stringReplace (message, gAgent.mRRInterface.getParcelName(), "(Parcel hidden)");
+				// hide every occurrence of the Region name if the location restriction is active
+				message = gAgent.mRRInterface.stringReplace (message, gAgent.getRegion()->getName(), "(Region hidden)");
+			}
+
+			if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+			{
+				// censor object IMs but not avatar IMs
+				message = gAgent.mRRInterface.getCensoredMessage (message);
+			}
+//mk
 			args["[NAME]"] = name;
 			args["[MESSAGE]"] = message;
 			LLNotifyBox::showXml("ObjectMessage", args);
@@ -1851,12 +2063,61 @@
 			}
 			else
 			{
-				// *TODO:translate -> [FIRST] [LAST] (maybe)
-				LLLureInfo* info = new LLLureInfo(from_id, session_id, FALSE);
-				args["[NAME]"] = name;
-				args["[MESSAGE]"] = message;
-				LLNotifyBox::showXml("OfferTeleport", args,
-									 lure_callback, (void*)info);
+//MK
+				LLVOAvatar* avatar = gAgent.getAvatarObject();
+				if (RRenabled 
+					&& (gAgent.mRRInterface.contains ("tplure")
+						&& !gAgent.mRRInterface.contains ("tplure:"+from_id.asString())
+					|| (gAgent.mRRInterface.mContainsUnsit && avatar && avatar->mIsSitting)))
+				{
+					std::string response = "The Resident you invited is prevented from accepting teleport offers. Please try again later.";
+					pack_instant_message(
+						gMessageSystem,
+						gAgent.getID(),
+						FALSE,
+						gAgent.getSessionID(),
+						from_id,
+						SYSTEM_FROM,
+						response.c_str(),
+						IM_ONLINE,
+						IM_CONSOLE_AND_CHAT_HISTORY);
+					gAgent.sendReliableMessage();
+					return;
+				}
+
+				if (RRenabled && gAgent.mRRInterface.contains ("recvim") &&
+					!gAgent.mRRInterface.contains ("recvim:"+from_id.asString()))
+				{
+					message = "(Hidden)";
+				}
+
+				if (RRenabled && gAgent.mRRInterface.mContainsShowloc) {
+					message = "(Hidden)";
+				}
+
+				if (RRenabled && (
+					gAgent.mRRInterface.contains ("accepttp:"+from_id.asString())
+					|| gAgent.mRRInterface.contains ("accepttp")))
+				{
+					// accepttp => the viewer acts like it was teleported by a god
+					gAgent.mRRInterface.setAllowCancelTp (FALSE);
+					LLLureInfo* info = new LLLureInfo(from_id, session_id, TRUE);
+					// do not show a message box, because you're about to be
+					// teleported.
+					lure_callback(0, (void *)info);
+				}
+				else
+				{
+//mk
+					// *TODO:translate -> [FIRST] [LAST] (maybe)
+					LLLureInfo* info = new LLLureInfo(from_id, session_id, FALSE);
+					args["[NAME]"] = name;
+					args["[MESSAGE]"] = message;
+					LLNotifyBox::showXml("OfferTeleport", args,
+									 	lure_callback, (void*)info);
+//MK
+				}
+//mk
 			}
 		}
 		break;
@@ -2161,6 +2422,9 @@
 	LLUUID		owner_id;
 	BOOL		is_owned_by_me = FALSE;
 	LLViewerObject*	chatter;
+//MK
+	BOOL twirly = FALSE;
+//mk
 
 	msg->getString("ChatData", "FromName", from_name);
 	chat.mFromName = from_name;
@@ -2199,18 +2463,20 @@
 	if (chatter)
 	{
 		chat.mPosAgent = chatter->getPositionAgent();
-		
 		// Make swirly things only for talking objects. (not script debug messages, though)
-		if (chat.mSourceType == CHAT_SOURCE_OBJECT 
+		if (chat.mSourceType == CHAT_SOURCE_OBJECT
 			&& chat.mChatType != CHAT_TYPE_DEBUG_MSG)
 		{
-			LLPointer<LLViewerPartSourceChat> psc = new LLViewerPartSourceChat(chatter->getPositionAgent());
-			psc->setSourceObject(chatter);
-			psc->setColor(color);
-			//We set the particles to be owned by the object's owner, 
-			//just in case they should be muted by the mute list
-			psc->setOwnerUUID(owner_id);
-			LLViewerPartSim::getInstance()->addPartSource(psc);
+//MK
+//			LLPointer<LLViewerPartSourceChat> psc = new LLViewerPartSourceChat(chatter->getPositionAgent());
+//			psc->setSourceObject(chatter);
+//			psc->setColor(color);
+//			//We set the particles to be owned by the object's owner, 
+//			//just in case they should be muted by the mute list
+//			psc->setOwnerUUID(owner_id);
+//			LLViewerPartSim::getInstance()->addPartSource(psc);
+			twirly = TRUE;
+//mk
 		}
 
 		// record last audible utterance
@@ -2236,7 +2502,36 @@
 		msg->getStringFast(_PREHASH_ChatData, _PREHASH_Message, mesg);
 
 		BOOL ircstyle = FALSE;
+//MK
+		if (chatter && chat.mChatType!=CHAT_TYPE_OWNER)
+		{
+			if (chatter->isAvatar () || !chatter->isAttachment () || 
+				!chatter->permYouOwner ())
+			{
+				if (RRenabled && gAgent.mRRInterface.contains ("recvchat") &&		// user is forbiddden to hear chat ...
+					!gAgent.mRRInterface.contains ("recvchat:"+from_id.asString()))	// ... and sender is no exception
+				{
+					chat.mFromName = from_name;				
+					chat.mText = gAgent.mRRInterface.crunchEmote (mesg, 20) + '\0';
+					mesg = chat.mText;
+				}
 
+				if (RRenabled && from_id != gAgent.getID() && gAgent.mRRInterface.mContainsShownames)
+				{
+					// also scramble the name of the chatter (replace with a dummy name)
+					if (chatter->isAvatar ())
+					{
+						from_name = gAgent.mRRInterface.getDummyName (from_name, chat.mAudible);
+					}
+					else
+					{
+						from_name = gAgent.mRRInterface.getCensoredMessage (from_name);
+					}
+					chat.mFromName = from_name;				
+				}
+			}
+		}
+//mk
 		// Look for IRC-style emotes here so chatbubbles work
 		std::string prefix = mesg.substr(0, 4);
 		if (prefix == "/me " || prefix == "/me'")
@@ -2299,8 +2594,57 @@
 			case CHAT_TYPE_WHISPER:
 				verb = " " + LLTrans::getString("whisper") + " ";
 				break;
-			case CHAT_TYPE_DEBUG_MSG:
 			case CHAT_TYPE_OWNER:
+//MK
+			// This is the actual handling of the commands sent by owned objects.
+			{
+				std::string mesg_str(mesg);
+				if (RRenabled && mesg_str.substr (0, 1) == RR_PREFIX)
+				{
+					std::string command = mesg_str.substr(1, mesg_str.length());
+					LLStringUtil::toLower(command);
+					if (gAgent.mRRInterface.handleCommand (from_id, command))
+					{
+						if (!gSavedSettings.getBOOL("RestrainedLifeDebug"))
+						{
+							return;
+						}
+						verb = " executes command: ";
+					}
+					else
+					{
+						verb = " fails command: ";
+					}
+				}
+				else if (RRenabled && mesg_str.length() >= 2 && mesg_str.substr (0, 2) == "  ") // this is a remark, only visible to non-RLV users
+				{
+					return;
+				}
+				else
+				{
+					if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+					{
+						// hide every occurrence of the Parcel name if the location restriction is active
+						mesg = gAgent.mRRInterface.stringReplace (mesg, 
+								gAgent.mRRInterface.getParcelName(), "(Parcel hidden)");
+						// hide every occurrence of the Region name if the location restriction is active
+						mesg = gAgent.mRRInterface.stringReplace (mesg, 
+								gAgent.getRegion()->getName(), "(Region hidden)");
+					}
+					
+					if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+					{
+						mesg = gAgent.mRRInterface.getCensoredMessage (mesg);
+						from_name = gAgent.mRRInterface.getCensoredMessage (from_name);
+						chat.mFromName = from_name;				
+					}
+
+					verb = ": ";
+				}
+				break;
+			}
+//mk
+			case CHAT_TYPE_DEBUG_MSG:
 			case CHAT_TYPE_NORMAL:
 				verb = ": ";
 				break;
@@ -2316,13 +2660,29 @@
 				verb = " say, ";
 				break;
 			}
-
-
+//MK
+			if (RRenabled && chatter && !chatter->isAvatar() && gAgent.mRRInterface.mContainsShownames)
+			{
+				// censor object chat but not avatar chat
+				mesg = gAgent.mRRInterface.getCensoredMessage (mesg);
+			}
+//mk
 			chat.mText = from_name;
 			chat.mText += verb;
 			chat.mText += mesg;
 		}
-		
+//MK
+		if (twirly)
+		{
+			LLPointer<LLViewerPartSourceChat> psc = new LLViewerPartSourceChat(chatter->getPositionAgent());
+			psc->setSourceObject(chatter);
+			psc->setColor(color);
+			//We set the particles to be owned by the object's owner, 
+			//just in case they should be muted by the mute list
+			psc->setOwnerUUID(owner_id);
+			LLViewerPartSim::getInstance()->addPartSource(psc);
+		}
+//mk		
 		if (chatter)
 		{
 			chat.mPosAgent = chatter->getPositionAgent();
@@ -2378,6 +2738,13 @@
 		gViewerWindow->setProgressCancelButtonVisible(TRUE, std::string("Cancel")); // *TODO: Translate
 	}
 
+//MK
+	if (RRenabled && !gAgent.mRRInterface.getAllowCancelTp())
+	{
+		gViewerWindow->setProgressCancelButtonVisible(FALSE, "");
+	}
+//mk
+
 	// Freeze the UI and show progress bar
 	// Note: could add data here to differentiate between normal teleport and death.
 
@@ -2404,7 +2771,10 @@
 	}
 	U32 teleport_flags = 0x0;
 	msg->getU32("Info", "TeleportFlags", teleport_flags);
-	if (teleport_flags & TELEPORT_FLAGS_DISABLE_CANCEL)
+	if (teleport_flags & TELEPORT_FLAGS_DISABLE_CANCEL
+//MK
+		|| (RRenabled && !gAgent.mRRInterface.getAllowCancelTp()))
+//mk
 	{
 		gViewerWindow->setProgressCancelButtonVisible(FALSE);
 	}
@@ -2538,6 +2908,14 @@
 // We're going to pretend to be a new agent
 void process_teleport_finish(LLMessageSystem* msg, void**)
 {
+//MK
+	if (RRenabled && !gAgent.mRRInterface.getAllowCancelTp())
+	{
+		// Cancel button was forcibly hidden by the RLV code ("@tpto") => allow it to show again
+		// for next time
+		gAgent.mRRInterface.setAllowCancelTp (TRUE);
+	}
+//mk
 	LL_DEBUGS("Messaging") << "Got teleport location message" << LL_ENDL;
 	LLUUID agent_id;
 	msg->getUUIDFast(_PREHASH_Info, _PREHASH_AgentID, agent_id);
@@ -2744,9 +3122,14 @@
 		if (avatarp)
 		{
 			// Chat the "back" SLURL. (DEV-4907)
-			LLChat chat("Teleport completed from " + gAgent.getTeleportSourceSLURL());
-			chat.mSourceType = CHAT_SOURCE_SYSTEM;
- 			LLFloaterChat::addChatHistory(chat);
+//MK
+			if (!RRenabled || !gAgent.mRRInterface.mContainsShowloc)
+			{
+//mk
+				LLChat chat("Teleport completed from " + gAgent.getTeleportSourceSLURL());
+				chat.mSourceType = CHAT_SOURCE_SYSTEM;
+ 				LLFloaterChat::addChatHistory(chat);
+			}
 
 			// Set the new position
 			avatarp->setPositionAgent(agent_pos);
@@ -4296,7 +4679,13 @@
 		// always include the object name and owner name 
 		notice.setArg("[OBJECTNAME]", cbdata->mObjectName);
 		notice.setArg("[OWNERNAME]", cbdata->mOwnerName);
-
+//MK
+		if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+		{
+			notice.setArg("[OBJECTNAME]", gAgent.mRRInterface.getCensoredMessage (cbdata->mObjectName));
+			notice.setArg("[OWNERNAME]", gAgent.mRRInterface.getDummyName (cbdata->mOwnerName));
+		}
+//mk
 		// try to lookup viewerobject that corresponds to the object that
 		// requested permissions (here, taskid->requesting object id)
 		BOOL foundpos = FALSE;
@@ -4311,7 +4700,14 @@
 			if (viewregion)
 			{
 				// got the region, so include the region and 3d coordinates of the object
-				notice.setArg("[REGIONNAME]", viewregion->getName());				
+//MK
+				if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+				{
+					notice.setArg("[REGIONNAME]", "(Region hidden)");
+				}
+				else
+//mk
+					notice.setArg("[REGIONNAME]", viewregion->getName());				
 				std::string formatpos = llformat("%.1f, %.1f,%.1f", objpos[VX], objpos[VY], objpos[VZ]);
 				notice.setArg("[REGIONPOS]", formatpos);
 
@@ -4513,7 +4909,15 @@
 			}
 		}
 		args["[QUESTIONS]"] = script_question;
-
+//MK
+		BOOL auto_deniable_permission = (
+			questions & (
+				LSCRIPTRunTimePermissionBits[1] //LSCRIPTRunTimePermissions::SCRIPT_PERMISSION_TAKE_CONTROLS]
+				//| LSCRIPTRunTimePermissionBits[3] //LSCRIPTRunTimePermissions::SCRIPT_PERMISSION_TRIGGER_ANIMATION]
+				| LSCRIPTRunTimePermissionBits[4] //LSCRIPTRunTimePermissions::SCRIPT_PERMISSION_ATTACH]
+			)
+		);
+//mk
 		LLScriptQuestionCBData *cbdata = new LLScriptQuestionCBData(taskid, itemid, sender, questions, object_name, owner_name);
 
 		// check whether cautions are even enabled or not
@@ -4526,12 +4930,42 @@
 			}
 			else
 			{
+//MK
+				if (RRenabled && auto_deniable_permission)
+				{
+					if (gAgent.mRRInterface.contains ("denypermission"))
+					{
+						script_question_cb (1 /* NO */, cbdata);
+						return;
+					}
+					else if (gAgent.mRRInterface.contains ("acceptpermission"))
+					{
+						script_question_cb (0 /* YES */, cbdata);
+						return;
+					}
+				}
+//mk	
 				// display the permissions request normally
 				LLNotifyBox::showXml("ScriptQuestion", args, FALSE, script_question_cb, cbdata);
 			}
 		}
 		else
 		{
+//MK
+			if (RRenabled && auto_deniable_permission)
+			{
+				if (gAgent.mRRInterface.contains ("denypermission"))
+				{
+					script_question_cb (1 /* NO */, cbdata);
+					return;
+				}
+				else if (gAgent.mRRInterface.contains ("acceptpermission"))
+				{
+					script_question_cb (0 /* YES */, cbdata);
+					return;
+				}
+			}
+//mk
 			// fall back to default behavior if cautions are entirely disabled
 			LLNotifyBox::showXml("ScriptQuestion", args, FALSE, script_question_cb, cbdata);
 		}
@@ -4816,7 +5250,14 @@
 		msg->addUUIDFast(_PREHASH_SessionID, gAgent.getSessionID());
 		msg->nextBlockFast(_PREHASH_Info);
 		msg->addU8Fast(_PREHASH_LureType, (U8)0); // sim will fill this in.
-		msg->addStringFast(_PREHASH_Message, text);
+//MK
+		if (RRenabled && gAgent.mRRInterface.contains ("sendim"))
+		{
+			msg->addStringFast(_PREHASH_Message, std::string("(Hidden)"));
+		}
+		else
+//mk
+			msg->addStringFast(_PREHASH_Message, text);
 		for(LLDynamicArray<LLUUID>::iterator itr = invitees->begin(); itr != invitees->end(); ++itr)
 		{
 			msg->nextBlockFast(_PREHASH_TargetData);
@@ -4848,6 +5289,24 @@
 
 	LLStringUtil::format_map_t edit_args;
 	edit_args["[REGION]"] = gAgent.getRegion()->getName();
+//MK
+	if (RRenabled && gAgent.mRRInterface.mContainsShowloc)
+	{
+		edit_args["[REGION]"] = "(Hidden)";
+		
+		// allow the tp offer if and only if the avatar is allowed to send tp offers to ALL
+		// the avatars in the list
+		for (LLDynamicArray<LLUUID>::iterator it = userdata->begin();
+			 it != userdata->end(); ++it)
+		{
+			if (!gAgent.mRRInterface.contains ("tplure:"+it->asString()))
+			{
+				// someone in the list is not an exception to tplure => eject
+				return;
+			}
+		}
+	}
+//mk
 	if (gAgent.isGodlike())
 	{
 		gViewerWindow->alertXmlEditText("OfferTeleportFromGod", edit_args,
diff -urN linden/indra/newview/llviewerwindow.cpp linden-patched/indra/newview/llviewerwindow.cpp
--- linden/indra/newview/llviewerwindow.cpp	2009-03-11 18:46:02.000000000 +0100
+++ linden-patched/indra/newview/llviewerwindow.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -244,6 +244,10 @@
 
 std::string	LLViewerWindow::sMovieBaseName;
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 extern void toggle_debug_menus(void*);
 
 
@@ -3268,6 +3272,20 @@
 						{
 							moveable_object_selected = TRUE;
 							this_object_movable = TRUE;
+//MK
+							// can't edit objects that someone is sitting on,
+							// when prevented from sit-tping
+							LLVOAvatar* avatar = gAgent.getAvatarObject();
+							if (RRenabled && (gAgent.mRRInterface.contains ("sittp")
+									|| (gAgent.mRRInterface.mContainsUnsit && avatar && avatar->mIsSitting)))
+							{
+								if (object->isSeat())
+								{
+									moveable_object_selected = FALSE;
+									this_object_movable = FALSE;
+								}
+							}
+//mk
 						}
 						all_selected_objects_move = all_selected_objects_move && this_object_movable;
 						all_selected_objects_modify = all_selected_objects_modify && object->permModify();
diff -urN linden/indra/newview/llvoavatar.cpp linden-patched/indra/newview/llvoavatar.cpp
--- linden/indra/newview/llvoavatar.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llvoavatar.cpp	2009-03-14 12:18:21.000000000 +0100
@@ -125,6 +125,10 @@
 #include "llvoicevisualizer.h" 
 #include "llvoiceclient.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 LLXmlTree LLVOAvatar::sXMLTree;
 LLXmlTree LLVOAvatar::sSkeletonXMLTree;
 LLVOAvatarSkeletonInfo* LLVOAvatar::sSkeletonInfo = NULL;
@@ -3103,7 +3107,13 @@
 						&& !gAgent.cameraMouselook()
 						&& (visible_chat || !gSavedSettings.getBOOL("RenderNameHideSelf"));
 	}
-
+//MK
+	// hide the names above the heads
+	if (RRenabled && gAgent.mRRInterface.mContainsShownames)
+	{
+		render_name = FALSE;
+	}
+//mk
 	if ( render_name )
 	{
 		BOOL new_name = FALSE;
@@ -6325,6 +6335,63 @@
 		return FALSE;
 	}
 
+//MK
+	if (RRenabled)
+	{
+		// if this inventory item is shared and does not contain any attachment info in its name, rename it for later (truncate the name first if needed)
+		LLViewerInventoryItem* item = gInventory.getItem (attachment->getItemID());
+		if (item && gAgent.mRRInterface.isUnderRlvShare (item))
+		{
+			if (gAgent.mRRInterface.findAttachmentPointFromName (item->getName()) == NULL)
+			{
+				if (item->isComplete())
+				{
+					std::string attach_name = getAttachedPointName (item->getUUID());
+					LLStringUtil::toLower (attach_name);
+					std::string item_name = item->getName();
+					if (item_name.length() >= DB_INV_ITEM_NAME_STR_LEN - 16)
+					{
+						// truncate if the original name is too long
+						item_name = item_name.substr (0, DB_INV_ITEM_NAME_STR_LEN - 16);
+					}
+					
+					if (item->getPermissions().allowModifyBy(gAgent.getID()))
+					{
+						// add the name of the attach point at the end of the name of the item
+						item->rename(item_name + " (" + attach_name + ")");
+						item->updateServer (FALSE);
+					}
+					else
+					{
+						// this item is no-mod, so we have to rename its parent directory instead,
+						// provided it is at least 2 levels below the shared root (we already know
+						// that the item is shared)
+						LLViewerInventoryCategory* cat_parent;
+						LLViewerInventoryCategory* cat_grandparent;
+						LLInventoryCategory* rlv_share = gAgent.mRRInterface.getRlvShare();
+						const LLUUID& parent_id = item->getParentUUID();
+						cat_parent = gInventory.getCategory (parent_id);
+						const LLUUID& grandparent_id = cat_parent->getParentUUID();
+						cat_grandparent = gInventory.getCategory (grandparent_id);
+						if (cat_parent && cat_grandparent
+							&& (LLInventoryCategory*)cat_parent != rlv_share
+							&& (LLInventoryCategory*)cat_grandparent != rlv_share)
+						{
+							if (gAgent.mRRInterface.findAttachmentPointFromName (cat_parent->getName())
+								 == NULL)
+							{
+								cat_parent->rename(".(" + attach_name + ")"); // don't write the whole name, it could contain commas (",") and fool @getinv
+								cat_parent->updateServer (FALSE);
+								gInventory.updateCategory (cat_parent);
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+//mk
+
 	if (viewer_object->isSelected())
 	{
 		LLSelectMgr::getInstance()->updateSelectionCenter();
@@ -6339,7 +6406,15 @@
 		gInventory.addChangedMask( LLInventoryObserver::LABEL, attachment->getItemID() );
 		gInventory.notifyObservers();
 	}
-
+//MK
+	// We must now check whether there is an object waiting to be reattached after having been kicked off while locked.
+	// If there is one, let's reattach it here, to its default attach point. Probably it will kick the one that we just attached here.
+	// Note : we need to delay the reattach a little, or we risk losing the item in the inventory.
+	if (RRenabled && gAgent.mRRInterface.sAssetToReattach.notNull())
+	{
+		gAgent.mRRInterface.sTimeBeforeReattaching = 50; // number of cycles before triggering the reattach (approx 5 seconds)
+	}
+//mk
 	return TRUE;
 }
 
@@ -6447,6 +6522,12 @@
 	mDrawable->mXform.setRotation(mDrawable->getWorldRotation() * inv_obj_rot);
 
 	gPipeline.markMoved(mDrawable, TRUE);
+//MK
+	if (RRenabled)
+	{
+		gAgent.mRRInterface.setSitTargetId (sit_object->getID());
+	}
+//mk
 	mIsSitting = TRUE;
 	mRoot.getXform()->setParent(&sit_object->mDrawable->mXform); // LLVOAvatar::sitOnObject
 	mRoot.setPosition(getPosition());
@@ -6484,6 +6565,12 @@
 
 	if (sit_object) 
 	{
+//MK
+		if (RRenabled)
+		{
+			gAgent.mRRInterface.setSitTargetId (LLUUID::null);
+		}
+//mk
 		stopMotionFromSource(sit_object->getID());
 		LLFollowCamMgr::setCameraActive(sit_object->getID(), FALSE);
 
diff -urN linden/indra/newview/llvovolume.cpp linden-patched/indra/newview/llvovolume.cpp
--- linden/indra/newview/llvovolume.cpp	2009-03-11 18:46:04.000000000 +0100
+++ linden-patched/indra/newview/llvovolume.cpp	2009-03-14 12:32:05.000000000 +0100
@@ -64,6 +64,11 @@
 #include "llworld.h"
 #include "llselectmgr.h"
 #include "pipeline.h"
+//MK
+#include "llagent.h"
+
+extern BOOL RRenabled;
+//mk
 
 const S32 MIN_QUIET_FRAMES_COALESCE = 30;
 const F32 FORCE_SIMPLE_RENDER_AREA = 512.f;
@@ -2084,7 +2089,11 @@
 {
 	LLMemType mt(LLMemType::MTYPE_SPACE_PARTITION);
 
-	if (facep->getViewerObject()->isSelected() && gHideSelectedObjects)
+	if (facep->getViewerObject()->isSelected()
+//MK
+		&& (!RRenabled || !gAgent.mRRInterface.mContainsEdit)
+//mk
+		&& gHideSelectedObjects)
 	{
 		return;
 	}
diff -urN linden/indra/newview/llwlparammanager.cpp linden-patched/indra/newview/llwlparammanager.cpp
--- linden/indra/newview/llwlparammanager.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/llwlparammanager.cpp	2009-03-14 11:56:59.000000000 +0100
@@ -61,6 +61,10 @@
 
 #include "curl/curl.h"
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 LLWLParamManager * LLWLParamManager::sInstance = NULL;
 
 LLWLParamManager::LLWLParamManager() :
@@ -231,8 +235,12 @@
 		llwarns << "Can't find " << name << llendl;
 		return;
 	}
-
-	
+//MK
+	if (RRenabled)
+	{
+		gAgent.mRRInterface.setLastLoadedPreset (name);
+	}
+//mk
 	if(propagate)
 	{
 		getParamSet(name, mCurParams);
diff -urN linden/indra/newview/pipeline.cpp linden-patched/indra/newview/pipeline.cpp
--- linden/indra/newview/pipeline.cpp	2009-03-11 18:46:03.000000000 +0100
+++ linden-patched/indra/newview/pipeline.cpp	2009-03-14 12:37:24.000000000 +0100
@@ -125,6 +125,10 @@
 extern BOOL gDisplaySwapBuffers;
 extern BOOL gDebugGL;
 
+//MK
+extern BOOL RRenabled;
+//mk
+
 // hack counter for rendering a fixed number of frames after toggling
 // fullscreen to work around DEV-5361
 static S32 sDelayedVBOEnable = 0;
@@ -1793,7 +1797,10 @@
 		return;
 	}
 	
-	if (gHideSelectedObjects)
+	if (gHideSelectedObjects
+//MK
+		&& (!RRenabled || !gAgent.mRRInterface.mContainsEdit))
+//mk
 	{
 		if (drawablep->getVObj().notNull() &&
 			drawablep->getVObj()->isSelected())
@@ -2742,7 +2749,11 @@
 		LLDrawable* drawable = vobj->mDrawable;
 		if (vobj->isDead() || 
 			vobj->isHUDAttachment() ||
-			(gHideSelectedObjects && vobj->isSelected()) ||
+			(gHideSelectedObjects
+//MK
+				&& (!RRenabled || !gAgent.mRRInterface.mContainsEdit)
+//mk
+				&& vobj->isSelected()) ||
 			drawable->isDead() || 
 			!hasRenderType(drawable->getRenderType()))
 		{
diff -urN linden/indra/newview/RRInterface.cpp linden-patched/indra/newview/RRInterface.cpp
--- linden/indra/newview/RRInterface.cpp	1970-01-01 01:00:00.000000000 +0100
+++ linden-patched/indra/newview/RRInterface.cpp	2009-03-16 23:11:16.000000000 +0100
@@ -0,0 +1,2117 @@
+#include "llviewerprecompiledheaders.h"
+
+#include "llagent.h"
+#include "lldrawpoolalpha.h"
+#include "llfloaterchat.h"
+#include "llfloaterdaycycle.h"
+#include "llfloaterenvsettings.h"
+#include "llfloatermap.h"
+#include "llfloaterpostprocess.h"
+#include "llfloatersettingsdebug.h"
+#include "llfloaterwater.h"
+#include "llfloaterwindlight.h"
+#include "llfloaterworldmap.h"
+#include "llfocusmgr.h"
+#include "llstartup.h"
+#include "llvoavatar.h"
+#include "llinventoryview.h"
+#include "lloverlaybar.h"
+#include "llurlsimstring.h"
+#include "lltracker.h"
+#include "llviewermenu.h"
+#include "llviewerobjectlist.h"
+#include "llviewerwindow.h"
+#include "llwaterparammanager.h"
+#include "llwlparammanager.h"
+#include "llinventorybridge.h"
+#include "llviewerregion.h"
+#include "pipeline.h"
+
+#include "RRInterface.h"
+
+extern BOOL RRNoSetEnv;
+
+#if !defined(max)
+#define max(a, b)	((a) > (b) ? (a) : (b))
+#endif
+
+// --
+// Local functions
+std::string dumpList2String (std::deque<std::string> list, std::string sep, int size = -1)
+{
+	bool found_one = false;
+	if (size < 0) size = (int)list.size();
+	std::string res = "";
+	for (int i = 0; i < (int)list.size() && i < size; ++i) {
+		if (found_one) res += sep;
+		found_one = true;
+		res += list[i];
+	}
+	return res;
+}
+
+int match (std::deque<std::string> list, std::string str)
+{
+	// does str contain list[0]/list[1]/.../list[n] ?
+	// yes => return the size of the list
+	// no  => try again after removing the last element
+	// return 0 if never found
+	unsigned int size = list.size();
+	std::string dump;
+	while (size > 0) {
+		dump = dumpList2String (list, "/", (int)size);
+		if (str.find (dump) != -1) return (int)size;
+		size--;
+	}
+	return 0;
+}
+
+std::deque<std::string> getSubList (std::deque<std::string> list, int min, int max = -1)
+{
+	if (min < 0) min = 0;
+	if (max < 0) max = list.size() - 1;
+	std::deque<std::string> res;
+	for (int i = min; i <= max; ++i) {
+		res.push_back (list[i]);
+	}
+	return res;
+}
+
+bool findMultiple (std::deque<std::string> list, std::string str)
+{
+	// returns true if all the tokens in list are contained into str
+	unsigned int size = list.size();
+	for (unsigned int i = 0; i < size; i++) {
+		if (str.find (list[i]) == -1) return false;
+	}
+	return true;
+}
+
+void refreshCachedVariable (std::string var)
+{
+	// Call this function when adding/removing a restriction only, i.e. in this file
+	// Test the cached variables in the code of the viewer itself
+	BOOL contained = gAgent.mRRInterface.contains (var);
+	if (var == "detach")		gAgent.mRRInterface.mContainsDetach = contained;
+	else if (var == "showinv")	gAgent.mRRInterface.mContainsShowinv = contained;
+	else if (var == "unsit")		gAgent.mRRInterface.mContainsUnsit = contained;
+	else if (var == "fartouch")	gAgent.mRRInterface.mContainsFartouch = contained;
+	else if (var == "showloc")	gAgent.mRRInterface.mContainsShowloc = contained;
+	else if (var == "shownames")	gAgent.mRRInterface.mContainsShownames = contained;
+	else if (var == "setenv")		gAgent.mRRInterface.mContainsSetenv = contained;
+	else if (var == "fly")		gAgent.mRRInterface.mContainsFly = contained;
+	else if (var == "edit")		gAgent.mRRInterface.mContainsEdit = contained;
+	else if (var == "rez")		gAgent.mRRInterface.mContainsRez = contained;
+}
+
+std::string getFirstName (std::string fullName)
+{
+	int ind = fullName.find (" ");
+	if (ind != -1) return fullName.substr (0, ind);
+	else return fullName;
+}
+
+std::string getLastName (std::string fullName)
+{
+	int ind = fullName.find (" ");
+	if (ind != -1) return fullName.substr (ind+1);
+	else return fullName;
+}
+// --
+
+
+
+
+
+RRInterface::RRInterface():
+	sInventoryFetched(FALSE),
+	sAllowCancelTp(TRUE),
+	sSitTargetId(),
+	sLastLoadedPreset(),
+	sTimeBeforeReattaching(0)
+{
+	sAllowedS32 = ",";
+
+	sAllowedU32 = 
+	",AvatarSex"			// 0 female, 1 male
+	",RenderResolutionDivisor"	// simulate blur, default is 1
+	",";
+
+	sAllowedF32 = ",";
+	sAllowedBOOLEAN = ",";
+	sAllowedSTRING = ",";
+	sAllowedVEC3 = ",";
+	sAllowedVEC3D = ",";
+	sAllowedRECT = ",";
+	sAllowedCOL4 = ",";
+	sAllowedCOL3 = ",";
+	sAllowedCOL4U = ",";
+
+	sAssetToReattach.setNull();
+}
+
+RRInterface::~RRInterface()
+{
+}
+
+std::string RRInterface::getVersion ()
+{
+	return "RestrainedLife viewer v"RR_VERSION; // there is no '+' between the string and the macro
+}
+
+BOOL RRInterface::isAllowed (LLUUID object_uuid, std::string action, BOOL log_it)
+{
+	BOOL debug = gSavedSettings.getBOOL("RestrainedLifeDebug") && log_it;
+	if (debug) {
+		llinfos << object_uuid.asString() << "      " << action << llendl;
+	}
+	RRMAP::iterator it = sSpecialObjectBehaviours.find (object_uuid.asString());
+	while (it != sSpecialObjectBehaviours.end() &&
+			it != sSpecialObjectBehaviours.upper_bound(object_uuid.asString()))
+	{
+		if (debug) {
+			llinfos << "  checking " << it->second << llendl;
+		}
+		if (it->second == action) {
+			if (debug) {
+				llinfos << "  => forbidden. " << llendl;
+			}
+			return FALSE;
+		}
+		it++;
+	}
+	if (debug) {
+		llinfos << "  => allowed. " << llendl;
+	}
+	return TRUE;
+}
+
+BOOL RRInterface::contains (std::string action)
+{
+	RRMAP::iterator it = sSpecialObjectBehaviours.begin ();
+	while (it != sSpecialObjectBehaviours.end()) {
+		if (it->second == action) {
+			return TRUE;
+		}
+		it++;
+	}
+	return FALSE;
+}
+
+BOOL RRInterface::containsSubstr (std::string action)
+{
+	RRMAP::iterator it = sSpecialObjectBehaviours.begin ();
+	while (it != sSpecialObjectBehaviours.end()) {
+		if (it->second.find (action) != -1) {
+			return TRUE;
+		}
+		it++;
+	}
+	return FALSE;
+}
+
+BOOL RRInterface::add (LLUUID object_uuid, std::string action, std::string option)
+{
+	if (gSavedSettings.getBOOL("RestrainedLifeDebug")) {
+		llinfos << object_uuid.asString() << "       " << action << "      " << option << llendl;
+	}
+	if (option!="") action+=":"+option;
+    
+	if (isAllowed (object_uuid, action)) {
+		if (action=="showinv") {
+			//LLInventoryView::cleanup ();
+			for (int i=0; i<LLInventoryView::sActiveViews.count(); ++i) {
+				if (LLInventoryView::sActiveViews.get(i)->getVisible()) {
+					LLInventoryView::sActiveViews.get(i)->setVisible (false);
+				}
+			}
+		}
+		else if (action=="showminimap") {
+			gFloaterMap->setVisible(FALSE);
+		}
+		else if (action=="shownames") {
+			LLFloaterChat::getInstance()->childSetVisible("active_speakers_panel", FALSE);
+		}
+		else if (action=="fly") {
+ 			gAgent.setFlying (FALSE);
+   		}
+		else if (action=="showworldmap" || action == "showloc") {
+			gFloaterWorldMap->setVisible(FALSE);
+		}
+		else if (action=="edit") {
+			LLPipeline::setRenderBeacons(FALSE);
+			LLPipeline::setRenderScriptedBeacons(FALSE);
+			LLPipeline::setRenderScriptedTouchBeacons(FALSE);
+			LLPipeline::setRenderPhysicalBeacons(FALSE);
+			LLPipeline::setRenderSoundBeacons(FALSE);
+			LLPipeline::setRenderParticleBeacons(FALSE);
+			LLPipeline::setRenderHighlights(FALSE);
+			LLDrawPoolAlpha::sShowDebugAlpha = FALSE;
+		}
+		else if (action=="setenv") {
+			if (RRNoSetEnv) {
+				return TRUE;
+			}
+			LLFloaterEnvSettings::instance()->close();
+			LLFloaterWater::instance()->close();
+			LLFloaterPostProcess::instance()->close();
+			LLFloaterDayCycle::instance()->close();
+			LLFloaterWindLight::instance()->close();
+			gSavedSettings.setBOOL("VertexShaderEnable", TRUE);
+			gSavedSettings.setBOOL("WindLightUseAtmosShaders", TRUE);
+		}
+		else if (action=="setdebug") {
+			if (!RRNoSetEnv) {
+				gSavedSettings.setBOOL("VertexShaderEnable", TRUE);
+				gSavedSettings.setBOOL("WindLightUseAtmosShaders", TRUE);
+			}
+		}
+
+		sSpecialObjectBehaviours.insert(std::pair<std::string, std::string>(object_uuid.asString(), action));
+		refreshCachedVariable(action);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+BOOL RRInterface::remove (LLUUID object_uuid, std::string action, std::string option)
+{
+	BOOL debug = gSavedSettings.getBOOL("RestrainedLifeDebug");
+	if (debug) {
+		llinfos << object_uuid.asString() << "       " << action << "      " << option << llendl;
+	}
+	if (option!="") action+=":"+option;
+	RRMAP::iterator it = sSpecialObjectBehaviours.find (object_uuid.asString());
+	while (it != sSpecialObjectBehaviours.end() &&
+			it != sSpecialObjectBehaviours.upper_bound(object_uuid.asString()))
+	{
+		if (debug) {
+			llinfos << "  checking " << it->second << llendl;
+		}
+		if (it->second == action) {
+			sSpecialObjectBehaviours.erase(it);
+			if (debug) {
+				llinfos << "  => removed. " << llendl;
+			}
+			refreshCachedVariable(action);
+			return TRUE;
+		}
+		it++;
+	}
+	return FALSE;
+}
+
+BOOL RRInterface::clear (LLUUID object_uuid, std::string command)
+{
+	BOOL debug = gSavedSettings.getBOOL("RestrainedLifeDebug");
+	if (debug) {
+		llinfos << object_uuid.asString() << "   /   " << command << llendl;
+	}
+	RRMAP::iterator it;
+	it = sSpecialObjectBehaviours.begin ();
+	while (it != sSpecialObjectBehaviours.end()) {
+		if (debug) {
+			llinfos << "  checking " << it->second << llendl;
+		}
+		if (it->first==object_uuid.asString() && (command=="" || it->second.find (command)!=-1)) {
+			if (debug) {
+				llinfos << it->second << " => removed. " << llendl;
+			}
+			std::string tmp = it->second;
+			sSpecialObjectBehaviours.erase(it);
+			refreshCachedVariable(tmp);
+			it = sSpecialObjectBehaviours.begin ();
+		}
+		else {
+			it++;
+		}
+	}
+	return TRUE;
+}
+
+BOOL RRInterface::garbageCollector (BOOL all) {
+	BOOL debug = gSavedSettings.getBOOL("RestrainedLifeDebug");
+    RRMAP::iterator it;
+    BOOL res=FALSE;
+    LLUUID uuid;
+    LLViewerObject *objp=NULL;
+    it = sSpecialObjectBehaviours.begin ();
+    while (it != sSpecialObjectBehaviours.end()) {
+		uuid.set (it->first);
+		if (all || !uuid.isNull ()) {
+//			if (debug) {
+//				llinfos << "testing " << it->first << llendl;
+//			}
+			objp = gObjectList.findObject(uuid);
+			if (!objp) {
+				if (debug) {
+					llinfos << it->first << " not found => cleaning... " << llendl;
+				}
+				clear (uuid);
+				res=TRUE;
+				it=sSpecialObjectBehaviours.begin ();
+			} else {
+				it++;
+			}
+		} else {
+			if (debug) {
+				llinfos << "ignoring " << it->second << llendl;
+			}
+			it++;
+		}
+    }
+    return res;
+}
+
+std::deque<std::string> RRInterface::parse (std::string str, std::string sep)
+{
+	int ind;
+	std::deque<std::string> res;
+	do {
+		ind=str.find(sep);
+		if (ind!=-1) {
+			res.push_back (str.substr (0, ind));
+			str=str.substr (ind+sep.length());
+		} else {
+			res.push_back (str);
+		}
+	} while (ind!=-1);
+	return res;
+}
+
+
+BOOL RRInterface::parseCommand (std::string command, std::string& behaviour, std::string& option, std::string& param)
+{
+	int ind = command.find("=");
+	behaviour=command;
+	option="";
+	param="";
+	if (ind!=-1) {
+	  behaviour=command.substr(0, ind);
+	  param=command.substr(ind+1);
+	  ind=behaviour.find(":");
+	  if (ind!=-1) {
+		  option=behaviour.substr(ind+1);
+		  behaviour=behaviour.substr(0, ind); // keep in this order (option first, then behav) or crash
+	  }
+	  return TRUE;
+	}
+	return FALSE;
+}
+
+BOOL RRInterface::handleCommand (LLUUID uuid, std::string command)
+{
+	// If there is another object still waiting to be automatically reattached, ignore all RLV commands
+	// to avoid an infinite loop if the one it will kick off is also locked.
+	if (sAssetToReattach.notNull() && sTimeBeforeReattaching > 0) return FALSE;
+	
+	BOOL debug = gSavedSettings.getBOOL("RestrainedLifeDebug");
+	// 1. check the command is actually a single one or a list of commands separated by ","
+	if (command.find (",")!=-1) {
+		BOOL res=TRUE;
+		std::deque<std::string> list_of_commands=parse (command, ",");
+		for (unsigned int i=0; i<list_of_commands.size (); ++i) {
+			if (!handleCommand (uuid, list_of_commands.at(i))) res=FALSE;
+		}
+		return res;
+	}
+	
+	// 2. this is a single command, possibly inside a 1-level recursive call (unimportant)
+	// if the viewer is not fully initialized and the user does not have control of their avatar,
+	// don't execute the command but retain it for later, when it is fully initialized
+	if (//!gViewerWindow->mWindow->getVisible() 
+//		|| !gViewerWindow->getActive()
+//		|| gViewerWindow->mWindow->getMinimized()
+		LLStartUp::getStartupState() != STATE_STARTED
+//		|| gViewerWindow->getShowProgress()
+//		|| gFocusMgr.focusLocked()
+	) {
+		Command cmd;
+		cmd.uuid=uuid;
+		cmd.command=command;
+		if (debug) {
+			llinfos << "Retaining command : " << command << llendl;
+		}
+		sRetainedCommands.push_back (cmd);
+		return TRUE;
+	}
+	
+	// 3. parse the command, which is of one of these forms :
+	// behav=param
+	// behav:option=param
+	std::string behav;
+	std::string option;
+	std::string param;
+	LLStringUtil::toLower(command);
+	if (parseCommand (command, behav, option, param)) // detach=n, recvchat=n, recvim=n, unsit=n, recvim:<uuid>=add, clear=tplure:
+	{
+		if (debug) {
+			llinfos << "[" << uuid.asString() << "]  [" << behav << "]  [" << option << "] [" << param << "]" << llendl;
+		}
+		if (behav=="version") return answerOnChat (param, getVersion ());
+		else if (behav=="getoutfit") return answerOnChat (param, getOutfit (option));
+		else if (behav=="getattach") return answerOnChat (param, getAttachments (option));
+		else if (behav=="getstatus") return answerOnChat (param, getStatus (uuid, option));
+		else if (behav=="getstatusall") {
+			uuid.setNull();
+			return answerOnChat (param, getStatus (uuid, option));
+		}
+		else if (behav=="getinv") return answerOnChat (param, getInventoryList (option));
+		else if (behav=="getinvworn") return answerOnChat (param, getInventoryList (option, TRUE));
+		else if (behav=="getsitid") return answerOnChat (param, getSitTargetId ().asString());
+		else if (behav=="getpath") return answerOnChat (param, getFullPath (getItem(uuid), option)); // option can be empty (=> find path to object) or the name of an attach pt or the name of a clothing layer
+		else if (behav=="findfolder") return answerOnChat (param, getFullPath (findCategoryUnderRlvShare (option)));
+		else if (behav.find ("getenv_") == 0) return answerOnChat (param, getEnvironment (behav));
+		else if (behav.find ("getdebug_") == 0) return answerOnChat (param, getDebugSetting (behav));
+		else {
+			if (param=="n" || param=="add") {
+				if (behav=="putinv" && !gSavedSettings.getBOOL("RestrainedLifeAllowPutInv")) {
+					return FALSE;
+				}
+				add (uuid, behav, option);
+			}
+			else if (param=="y" || param=="rem") remove (uuid, behav, option);
+			else if (behav=="clear") clear (uuid, param);
+			else if (param=="force") force (uuid, behav, option);
+			else return FALSE;
+		}
+	}
+	else // clear
+	{
+		if (debug) {
+			llinfos << uuid.asString() << "       " << behav << llendl;
+		}
+		if (behav=="clear") clear (uuid);
+		else return FALSE;
+	}
+	return TRUE;
+}
+
+BOOL RRInterface::fireCommands ()
+{
+	if (sRetainedCommands.size ()) {
+		if (gSavedSettings.getBOOL("RestrainedLifeDebug")) {
+			llinfos << "Firing commands : " << sRetainedCommands.size () << llendl;
+		}
+	}
+	Command cmd;
+	BOOL ok=TRUE;
+	while (!sRetainedCommands.empty ()) {
+		cmd=sRetainedCommands[0];
+		ok=ok & handleCommand (cmd.uuid, cmd.command);
+		sRetainedCommands.pop_front ();
+	}
+	return ok;
+}
+
+static void force_sit(LLUUID object_uuid)
+{
+	LLViewerObject *object = gObjectList.findObject(object_uuid);
+	if (object) {
+		LLVOAvatar* avatar = gAgent.getAvatarObject();
+		if (gAgent.mRRInterface.mContainsUnsit && avatar && avatar->mIsSitting) {
+			// Do not allow a script to force the avatar to sit somewhere if already forced to stay sitting here
+			return;
+		}
+		if (gAgent.mRRInterface.contains ("sittp") || gAgent.mRRInterface.contains ("fartouch")) {
+			// Do not allow a script to force the avatar to sit somewhere far when under @sittp
+			LLVector3 pos = object->getPositionRegion();
+			pos -= gAgent.getPositionAgent ();
+			if (pos.magVec () >= 1.5)
+			{
+				return;
+			}
+		}
+		gMessageSystem->newMessageFast(_PREHASH_AgentRequestSit);
+		gMessageSystem->nextBlockFast(_PREHASH_AgentData);
+		gMessageSystem->addUUIDFast(_PREHASH_AgentID, gAgent.getID());
+		gMessageSystem->addUUIDFast(_PREHASH_SessionID, gAgent.getSessionID());
+		gMessageSystem->nextBlockFast(_PREHASH_TargetObject);
+		gMessageSystem->addUUIDFast(_PREHASH_TargetID, object->mID);
+		gMessageSystem->addVector3Fast(_PREHASH_Offset,
+			gAgent.calcFocusOffset(object, gAgent.getPositionAgent(), (S32)0.0f, (S32)0.0f));
+		object->getRegion()->sendReliableMessage();
+	}
+}
+
+BOOL RRInterface::force (LLUUID object_uuid, std::string command, std::string option)
+{
+	BOOL debug = gSavedSettings.getBOOL("RestrainedLifeDebug");
+	if (debug) {
+		llinfos << command << "     " << option << llendl;
+	}
+	if (command=="sit") { // sit:UUID
+		BOOL allowed_to_sittp=TRUE;
+		if (!isAllowed (object_uuid, "sittp")) {
+			allowed_to_sittp=FALSE;
+			remove (object_uuid, "sittp", "");
+		}
+		LLUUID uuid (option);
+		force_sit (uuid);
+		if (!allowed_to_sittp) add (object_uuid, "sittp", "");
+	}
+	else if (command=="unsit") { // unsit
+		if (debug) {
+			llinfos << "trying to unsit" << llendl;
+		}
+		if (gAgent.getAvatarObject() &&
+			gAgent.getAvatarObject()->mIsSitting) {
+			if (debug) {
+				llinfos << "found avatar object" << llendl;
+			}
+			if (gAgent.mRRInterface.mContainsUnsit) {
+				if (debug) {
+					llinfos << "prevented from unsitting" << llendl;
+				}
+				return TRUE;
+			}
+			if (debug) {
+				llinfos << "unsitting agent" << llendl;
+			}
+			LLOverlayBar::onClickStandUp(NULL);
+		}
+	}
+	else if (command=="remoutfit") { // remoutfit:shoes
+		if (option=="") {
+			gAgent.removeWearable (WT_GLOVES);
+			gAgent.removeWearable (WT_JACKET);
+			gAgent.removeWearable (WT_PANTS);
+			gAgent.removeWearable (WT_SHIRT);
+			gAgent.removeWearable (WT_SHOES);
+			gAgent.removeWearable (WT_SKIRT);
+			gAgent.removeWearable (WT_SOCKS);
+			gAgent.removeWearable (WT_UNDERPANTS);
+			gAgent.removeWearable (WT_UNDERSHIRT);
+		} else {
+			EWearableType type = getOutfitLayerAsType (option);
+			if (type != WT_INVALID) gAgent.removeWearable (type); // remove by layer
+			else forceDetachByName (option); // remove by category (in RLV share)
+		}
+	}
+	else if (command=="detach") { // detach:chest=force OR detach:restraints/cuffs=force
+		LLViewerJointAttachment* attachpt = findAttachmentPointFromName (option, TRUE); // exact name
+		if (attachpt != NULL || option == "") return forceDetach (option); // remove by attach pt
+		else forceDetachByName (option);
+	}
+	else if (command=="detachthis") { // detachthis=force to detach the folder containing this object
+		return forceDetachByName (getFullPath (getItem(object_uuid), option), FALSE);
+	}
+	else if (command=="detachall") { // detachall:cuffs=force to detach a folder and its subfolders
+		return forceDetachByName (option, TRUE);
+	}
+	else if (command=="detachallthis") { // detachallthis=force to detach the folder containing this object and also its subfolders
+		return forceDetachByName (getFullPath (getItem(object_uuid), option), TRUE);
+	}
+	else if (command=="tpto") { // tpto:X/Y/Z=force (X, Y, Z are GLOBAL coordinates)
+		BOOL allowed_to_tploc=TRUE;
+		BOOL allowed_to_unsit=TRUE;
+		BOOL res;
+		if (!isAllowed (object_uuid, "tploc")) {
+			allowed_to_tploc=FALSE;
+			remove (object_uuid, "tploc", "");
+		}
+		if (!isAllowed (object_uuid, "unsit")) {
+			allowed_to_unsit=FALSE;
+			remove (object_uuid, "unsit", "");
+		}
+		res = forceTeleport (option);
+		if (!allowed_to_tploc) add (object_uuid, "tploc", "");
+		if (!allowed_to_unsit) add (object_uuid, "unsit", "");
+		return res;
+	}
+	else if (command=="attach" || command == "addoutfit") { // attach:cuffs=force
+		return forceAttach (option);
+	}
+	else if (command=="attachthis") { // attachthis=force to attach the folder containing this object
+		return forceAttach (getFullPath (getItem(object_uuid), option), FALSE);
+	}
+	else if (command=="attachall") { // attachall:cuffs=force to attach a folder and its subfolders
+		return forceAttach (option, TRUE);
+	}
+	else if (command=="attachallthis") { // attachallthis=force to attach the folder containing this object and its subfolders
+		return forceAttach (getFullPath (getItem(object_uuid), option), TRUE);
+	}
+	else if (command.find ("setenv_") == 0) {
+		BOOL res = TRUE;
+		BOOL allowed = TRUE;
+		if (!RRNoSetEnv) {
+			if (!isAllowed (object_uuid, "setenv")) {
+				allowed=FALSE;
+				remove (object_uuid, "setenv", "");
+			}
+			if (!mContainsSetenv) res = forceEnvironment (command, option);
+			if (!allowed) add (object_uuid, "setenv", "");
+		}
+		return res;
+	}
+	else if (command.find ("setdebug_") == 0) {
+		BOOL res = TRUE;
+		BOOL allowed = TRUE;
+		if (!isAllowed (object_uuid, "setdebug")) {
+			allowed=FALSE;
+			remove (object_uuid, "setdebug", "");
+		}
+		if (!contains("setdebug")) res = forceDebugSetting (command, option);
+		if (!allowed) add (object_uuid, "setdebug", "");
+		return res;
+	}
+	return TRUE;
+}
+
+BOOL RRInterface::answerOnChat (std::string channel, std::string msg)
+{
+	if (channel == "0") return FALSE; // protection against abusive "@getstatus=0" commands
+	if (atoi (channel.c_str()) <= 0) return FALSE; // prevent from trying to say something on a negative channel, or on a non-numerical channel
+	gChatBar->sendChatFromViewer("/"+channel+" "+msg, CHAT_TYPE_SHOUT, FALSE);
+	if (gSavedSettings.getBOOL("RestrainedLifeDebug")) {
+		llinfos << "/" << channel << " " << msg << llendl;
+	}
+	return TRUE;
+}
+
+std::string RRInterface::crunchEmote (std::string msg, unsigned int truncateTo) {
+	std::string crunched = msg;
+
+	if (msg.find ("/me ") == 0 || msg.find ("/me'") == 0) {
+		// Only allow emotes without "spoken" text.
+		// Forbid text containing any symbol which could be used as quotes.
+		if (msg.find ("\"") != -1 || msg.find ("''") != -1
+		    || msg.find ("(")  != -1 || msg.find (")")  != -1
+		    || msg.find (" -") != -1 || msg.find ("- ") != -1
+		    || msg.find ("*")  != -1 || msg.find ("=")  != -1
+		    || msg.find ("^")  != -1 || msg.find ("_")  != -1
+		    || msg.find ("?")  != -1 || msg.find ("~")  != -1)
+		{
+			crunched = "...";
+		}
+		else if (!contains ("emote")) {
+			// Only allow short emotes.
+			int i = msg.find (".");
+			if (i != -1) {
+				crunched = msg.substr (0, ++i);
+			}
+			if (crunched.length () > truncateTo) {
+				crunched = crunched.substr (0, truncateTo);
+			}
+		}
+	}
+	else if (msg.find ("/") == 0) {
+		// only allow short gesture names (to avoid cheats).
+		if (msg.length () > 7) { // allows things like "/ao off", "/hug X"
+			crunched = "...";
+		}
+	}
+	else if (msg.find ("((") != 0 || msg.find ("))") != msg.length () - 2) {
+		// Only allow OOC chat, starting with "((" and ending with "))".
+		crunched = "...";
+	}
+	return crunched;
+}
+
+std::string RRInterface::getOutfitLayerAsString (EWearableType layer)
+{
+	switch (layer) {
+		case WT_SKIN: return WS_SKIN;
+		case WT_GLOVES: return WS_GLOVES;
+		case WT_JACKET: return WS_JACKET;
+		case WT_PANTS: return WS_PANTS;
+		case WT_SHIRT: return WS_SHIRT;
+		case WT_SHOES: return WS_SHOES;
+		case WT_SKIRT: return WS_SKIRT;
+		case WT_SOCKS: return WS_SOCKS;
+		case WT_UNDERPANTS: return WS_UNDERPANTS;
+		case WT_UNDERSHIRT: return WS_UNDERSHIRT;
+		case WT_EYES: return WS_EYES;
+		case WT_HAIR: return WS_HAIR;
+		case WT_SHAPE: return WS_SHAPE;
+		default: return "";
+	}
+}
+
+EWearableType RRInterface::getOutfitLayerAsType (std::string layer)
+{
+	if (layer==WS_SKIN) return WT_SKIN;
+	if (layer==WS_GLOVES) return WT_GLOVES;
+	if (layer==WS_JACKET) return WT_JACKET;
+	if (layer==WS_PANTS) return WT_PANTS;
+	if (layer==WS_SHIRT) return WT_SHIRT;
+	if (layer==WS_SHOES) return WT_SHOES;
+	if (layer==WS_SKIRT) return WT_SKIRT;
+	if (layer==WS_SOCKS) return WT_SOCKS;
+	if (layer==WS_UNDERPANTS) return WT_UNDERPANTS;
+	if (layer==WS_UNDERSHIRT) return WT_UNDERSHIRT;
+	if (layer==WS_EYES) return WT_EYES;
+	if (layer==WS_HAIR) return WT_HAIR;
+	if (layer==WS_SHAPE) return WT_SHAPE;
+	return WT_INVALID;
+}
+
+std::string RRInterface::getOutfit (std::string layer)
+{
+	if (layer==WS_SKIN) return (gAgent.getWearable (WT_SKIN) != NULL? "1" : "0");
+	if (layer==WS_GLOVES) return (gAgent.getWearable (WT_GLOVES) != NULL? "1" : "0");
+	if (layer==WS_JACKET) return (gAgent.getWearable (WT_JACKET) != NULL? "1" : "0");
+	if (layer==WS_PANTS) return (gAgent.getWearable (WT_PANTS) != NULL? "1" : "0");
+	if (layer==WS_SHIRT)return (gAgent.getWearable (WT_SHIRT) != NULL? "1" : "0");
+	if (layer==WS_SHOES) return (gAgent.getWearable (WT_SHOES) != NULL? "1" : "0");
+	if (layer==WS_SKIRT) return (gAgent.getWearable (WT_SKIRT) != NULL? "1" : "0");
+	if (layer==WS_SOCKS) return (gAgent.getWearable (WT_SOCKS) != NULL? "1" : "0");
+	if (layer==WS_UNDERPANTS) return (gAgent.getWearable (WT_UNDERPANTS) != NULL? "1" : "0");
+	if (layer==WS_UNDERSHIRT) return (gAgent.getWearable (WT_UNDERSHIRT) != NULL? "1" : "0");
+	if (layer==WS_EYES) return (gAgent.getWearable (WT_EYES) != NULL? "1" : "0");
+	if (layer==WS_HAIR) return (gAgent.getWearable (WT_HAIR) != NULL? "1" : "0");
+	if (layer==WS_SHAPE) return (gAgent.getWearable (WT_SHAPE) != NULL? "1" : "0");
+	return getOutfit (WS_GLOVES)+getOutfit (WS_JACKET)+getOutfit (WS_PANTS)
+			+getOutfit (WS_SHIRT)+getOutfit (WS_SHOES)+getOutfit (WS_SKIRT)
+			+getOutfit (WS_SOCKS)+getOutfit (WS_UNDERPANTS)+getOutfit (WS_UNDERSHIRT)
+			+getOutfit (WS_SKIN)+getOutfit (WS_EYES)+getOutfit (WS_HAIR)+getOutfit (WS_SHAPE);
+}
+
+std::string RRInterface::getAttachments (std::string attachpt)
+{
+	BOOL debug = gSavedSettings.getBOOL("RestrainedLifeDebug");
+	std::string res="";
+	std::string name;
+	if (attachpt=="") res+="0"; // to match the LSL macros
+	LLVOAvatar* avatar = gAgent.getAvatarObject();
+	for (LLVOAvatar::attachment_map_t::iterator iter = avatar->mAttachmentPoints.begin(); 
+		iter != avatar->mAttachmentPoints.end(); iter++)
+	{
+		LLVOAvatar::attachment_map_t::iterator curiter = iter;
+		LLViewerJointAttachment* attachment = curiter->second;
+		name=attachment->getName ();
+		LLStringUtil::toLower(name);
+		if (debug) {
+			llinfos << "trying <" << name << ">" << llendl;
+		}
+		if (attachpt=="" || attachpt==name) {
+			if (!attachment->getItemID().isNull()) res+="1"; //attachment->getName ();
+			else res+="0";
+		}
+	}
+	return res;
+}
+
+std::string RRInterface::getStatus (LLUUID object_uuid, std::string rule)
+{
+	std::string res="";
+	std::string name;
+	RRMAP::iterator it;
+	if (object_uuid.isNull()) {
+		it = sSpecialObjectBehaviours.begin();
+	}
+	else {
+		it = sSpecialObjectBehaviours.find (object_uuid.asString());
+	}
+	bool is_first=true;
+	while (it != sSpecialObjectBehaviours.end() &&
+			(object_uuid.isNull() || it != sSpecialObjectBehaviours.upper_bound(object_uuid.asString()))
+	)
+	{
+		if (rule=="" || it->second.find (rule)!=-1) {
+			//if (!is_first) 
+			res+="/";
+			res+=it->second;
+			is_first=false;
+		}
+		it++;
+	}
+	return res;
+}
+
+BOOL RRInterface::forceDetach (std::string attachpt)
+{
+	BOOL debug = gSavedSettings.getBOOL("RestrainedLifeDebug");
+	std::string name;
+	BOOL res=FALSE;
+	LLVOAvatar* avatar = gAgent.getAvatarObject();
+	for (LLVOAvatar::attachment_map_t::iterator iter = avatar->mAttachmentPoints.begin(); 
+		 iter != avatar->mAttachmentPoints.end(); iter++)
+	{
+		LLVOAvatar::attachment_map_t::iterator curiter = iter;
+		LLViewerJointAttachment* attachment = curiter->second;
+		name=attachment->getName ();
+		LLStringUtil::toLower(name);
+		if (debug) {
+			llinfos << "trying <" << name << ">" << llendl;
+		}
+		if (attachpt=="" || attachpt==name) {
+			if (debug) {
+				llinfos << "found => detaching" << llendl;
+			}
+			if (attachment->getObject()) {
+				handle_detach_from_avatar ((void*)attachment);
+				res=TRUE;
+			}
+		}
+	}
+	return res;
+}
+
+BOOL RRInterface::hasLockedHuds ()
+{
+	LLVOAvatar* avatar = gAgent.getAvatarObject();
+	if (avatar == NULL) return FALSE;
+	for (LLVOAvatar::attachment_map_t::iterator iter = avatar->mAttachmentPoints.begin(); 
+		 iter != avatar->mAttachmentPoints.end(); iter++)
+	{
+		LLVOAvatar::attachment_map_t::iterator curiter = iter;
+		LLViewerJointAttachment* attachment = curiter->second;
+		LLViewerObject* obj;
+		if (attachment && (obj=attachment->getObject()) != NULL) {
+			if (obj->isHUDAttachment()) {
+				if (!isAllowed (obj->getID(), "detach", FALSE)) return TRUE;
+			}
+		}
+	}
+	return FALSE;
+}
+
+
+std::string RRInterface::getInventoryList (std::string path, BOOL withWornInfo /* = FALSE */)
+{
+	std::string res = "";
+	LLInventoryModel::cat_array_t* cats;
+	LLInventoryModel::item_array_t* items;
+	LLInventoryCategory* root = NULL;
+	if (path == "") root = getRlvShare();
+	else root = getCategoryUnderRlvShare (path);
+	
+	if (root) {
+		gInventory.getDirectDescendentsOf (root->getUUID(), cats, items);
+		if(cats) {
+			S32 count = cats->count();
+			bool found_one = false;
+			if (withWornInfo) {
+				res += "|" + getWornItems (root);
+				found_one = true;
+			}
+			for(S32 i = 0; i < count; ++i) {
+				LLInventoryCategory* cat = cats->get(i);
+				std::string name = cat->getName();
+				if (name != "" && name[0] !=  '.') { // hidden folders => invisible to the list
+					if (found_one) res += ",";
+					res += name.c_str();
+					if (withWornInfo) {
+						res += "|" + getWornItems (cat);
+					}
+					found_one = true;
+				}
+			}
+		}
+	}
+
+	return res;
+}
+
+std::string RRInterface::getWornItems (LLInventoryCategory* cat)
+{
+	// Returns a string of 2 digits according to the proportion of worn items in this folder and its children :
+	// First digit is this folder, second digit is children folders
+	// 0 : No item contained in the folder
+	// 1 : Some items contained but none is worn
+	// 2 : Some items contained and some of them are worn
+	// 3 : Some items contained and all of them are worn
+	std::string res_as_string = "0";
+	int res			= 0;
+	int subRes		= 0;
+	int prevSubRes	= 0;
+	int nbItems		= 0;
+	int nbWorn		= 0;
+	BOOL isNoMod	= FALSE;
+	BOOL isRoot		= (getRlvShare() == cat);
+	
+	// if cat exists, scan all the items inside it
+	if (cat) {
+	
+		LLInventoryModel::cat_array_t* cats;
+		LLInventoryModel::item_array_t* items;
+		
+		// retrieve all the objects contained in this folder
+		gInventory.getDirectDescendentsOf (cat->getUUID(), cats, items);
+		if (!isRoot && items) { // do not scan the shared root
+		
+			// scan them one by one
+			S32 count = items->count();
+			for(S32 i = 0; i < count; ++i) {
+			
+				LLViewerInventoryItem* item = (LLViewerInventoryItem*)items->get(i);
+
+				if (item) {
+					LLVOAvatar* avatar = gAgent.getAvatarObject();
+					if (item->getType() == LLAssetType::AT_OBJECT
+					 || item->getType() == LLAssetType::AT_CLOTHING
+					 || item->getType() == LLAssetType::AT_BODYPART
+					) {
+						nbItems++;
+					}
+					if( avatar && avatar->isWearingAttachment( item->getUUID() ) 
+						|| gAgent.isWearingItem (item->getUUID())) nbWorn++;
+
+					// special case : this item is no-mod, hence we need to check its parent folder
+					// is correctly named, and that the item is alone in its folder.
+					// If so, then the calling method will have to deal with a special character instead
+					// of a number
+					if (count == 1
+					 && item->getType() == LLAssetType::AT_OBJECT
+					 && !item->getPermissions().allowModifyBy(gAgent.getID())) {
+						if (findAttachmentPointFromName (cat->getName()) != NULL) {
+							isNoMod = TRUE;
+						}
+					}
+				}
+			}
+		}
+		
+		// scan every subfolder of the folder we are scanning, recursively
+		// note : in the case of no-mod items we shouldn't have sub-folders, so no need to check
+		if (cats && !isNoMod) {
+		
+			S32 count = cats->count();
+			for(S32 i = 0; i < count; ++i) {
+
+				LLViewerInventoryCategory* cat_child = (LLViewerInventoryCategory*)cats->get(i);
+
+				if (cat_child) {
+					std::string tmp = getWornItems (cat_child);
+					// translate the result for no-mod items into something the upper levels can understand
+					if (tmp == "N") {
+						if (!isRoot) {
+							nbWorn++;
+							nbItems++;
+						}
+					}
+					else if (tmp== "n") {
+						if (!isRoot) {
+							nbItems++;
+						}
+					}
+					else if (cat_child->getName() != "" && cat_child->getName()[0] != '.') { // we don't want to include invisible folders, except the ones containing a no-mod item
+						// This is an actual sub-folder with several items and sub-folders inside,
+						// so retain its score to integrate it into the current one
+						// As it is a sub-folder, to integrate it we need to reduce its score first (consider "0" as "ignore")
+						// "00" = 0, "01" = 1, "10" = 1, "30" = 3, "03" = 3, "33" = 3, all the rest gives 2 (some worn, some not worn)
+						if      (tmp == "00")                               subRes = 0;
+						else if (tmp == "11" || tmp == "01" || tmp == "10") subRes = 1;
+						else if (tmp == "33" || tmp == "03" || tmp == "30") subRes = 3;
+						else subRes = 2;
+
+						// Then we must combine with the previous sibling sub-folders
+						// Same rule as above, set to 2 in all cases except when prevSubRes == subRes or when either == 0 (nothing present, ignore)
+						if      (prevSubRes == 0 && subRes == 0) subRes = 0;
+						else if (prevSubRes == 0 && subRes == 1) subRes = 1;
+						else if (prevSubRes == 1 && subRes == 0) subRes = 1;
+						else if (prevSubRes == 1 && subRes == 1) subRes = 1;
+						else if (prevSubRes == 0 && subRes == 3) subRes = 3;
+						else if (prevSubRes == 3 && subRes == 0) subRes = 3;
+						else if (prevSubRes == 3 && subRes == 3) subRes = 3;
+						else subRes = 2;
+						prevSubRes = subRes;
+					}
+				}
+			}
+		}
+	}
+
+	if (isNoMod) {
+		// the folder contains one no-mod object and is named from an attachment point
+		// => return a special character that will be handled by the calling method
+		if (nbWorn > 0) return "N";
+		else return "n";
+	}
+	else {
+		if (isRoot || nbItems == 0) res = 0; // forcibly hide all items contained directly under #RLV
+		else if (nbWorn >= nbItems) res = 3;
+		else if (nbWorn > 0) res = 2;
+		else res = 1;
+	}
+	std::stringstream str;
+	str << res;
+	str << subRes;
+	res_as_string = str.str();
+	return res_as_string;
+}
+
+LLInventoryCategory* RRInterface::getRlvShare ()
+{
+//	BOOL debug = gSavedSettings.getBOOL("RestrainedLifeDebug");
+	LLInventoryModel::cat_array_t* cats;
+	LLInventoryModel::item_array_t* items;
+	gInventory.getDirectDescendentsOf (
+					gInventory.findCategoryUUIDForType(LLAssetType::AT_CATEGORY), cats, items
+	);
+
+	if(cats) {
+		S32 count = cats->count();
+		for(S32 i = 0; i < count; ++i) {
+			LLInventoryCategory* cat = cats->get(i);
+			std::string name = cat->getName();
+			if (name == RR_SHARED_FOLDER) {
+//				if (debug) {
+//					llinfos << "found " << name << llendl;
+//				}
+				return cat;
+			}
+		}
+	}
+	return NULL;
+}
+
+BOOL RRInterface::isUnderRlvShare (LLInventoryItem* item)
+{
+	if (item == NULL) return FALSE;
+	LLInventoryCategory* res = NULL;
+	LLInventoryCategory* rlv = getRlvShare();
+	if (rlv == NULL) return FALSE;
+	LLUUID root_id = gInventory.findCategoryUUIDForType(LLAssetType::AT_CATEGORY);
+	
+	const LLUUID& cat_id = item->getParentUUID();
+	res = gInventory.getCategory (cat_id);
+	
+	while (res && res->getUUID() != root_id) {
+		if (res == rlv) return TRUE;
+		const LLUUID& parent_id = res->getParentUUID();
+		res = gInventory.getCategory (parent_id);
+	}
+	return FALSE;
+}
+
+void RRInterface::renameAttachment (LLInventoryItem* item, LLViewerJointAttachment* attachment)
+{
+  // DEPRECATED : done directly in the viewer code
+	// if item is worn and shared, check its name
+	// if it doesn't contain the name of attachment, append it
+	// (but truncate the name first if it's too long)
+	if (!item || !attachment) return;
+	LLVOAvatar* avatar = gAgent.getAvatarObject();
+	
+	if( avatar && avatar->isWearingAttachment( item->getUUID() ) ) {
+		if (isUnderRlvShare (item)) {
+			LLViewerJointAttachment* attachpt = findAttachmentPointFromName (item->getName());
+			if (attachpt == NULL) {
+				
+			}
+		}
+	}
+}
+
+LLInventoryCategory* RRInterface::getCategoryUnderRlvShare (std::string catName, LLInventoryCategory* root)
+{
+	if (root == NULL) root = getRlvShare();
+	if (catName == "") return root;
+	LLStringUtil::toLower (catName);
+	std::deque<std::string> tokens = parse (catName, "/");
+
+	// Preliminary action : remove everything after pipes ("|"), including pipes themselves
+	// This way we can feed the result of a @getinvworn command directly into this method
+	// without having to clean what is after the pipes
+	int nb = tokens.size();
+	for (int i=0; i<nb; ++i) {
+		std::string tok = tokens[i];
+		int ind = tok.find ("|");
+		if (ind != -1) {
+			tok = tok.substr (0, ind);
+			tokens[i] = tok;
+		}
+	}
+	
+	if (root) {
+
+		LLInventoryModel::cat_array_t* cats;
+		LLInventoryModel::item_array_t* items;
+		gInventory.getDirectDescendentsOf (root->getUUID(), cats, items);
+		
+		if(cats) {
+			S32 count = cats->count();
+			LLInventoryCategory* cat = NULL;
+			
+			// we need to scan first and retain the best match
+			int max_size_index = -1;
+			int max_size = 0;
+			
+			for(S32 i = 0; i < count; ++i) {
+				cat = cats->get(i);
+				std::string name = cat->getName();
+				LLStringUtil::toLower (name);
+				
+				int size = match (tokens, name);
+				if (size > max_size) {
+					max_size = size;
+					max_size_index = i;
+				}
+			}
+
+			// only now we can grab the best match and either continue deeper or return it
+			if (max_size > 0) {
+				cat = cats->get(max_size_index);
+				if (max_size == tokens.size()) return cat;
+				else return getCategoryUnderRlvShare (
+									dumpList2String (
+										getSubList (tokens, max_size)
+									, "/")
+								, cat);
+			}
+		}
+	}
+
+	if (gSavedSettings.getBOOL("RestrainedLifeDebug")) {
+		llinfos << "category not found" << llendl;
+	}
+	return NULL;
+}
+
+LLInventoryCategory* RRInterface::findCategoryUnderRlvShare (std::string catName, LLInventoryCategory* root)
+{
+	if (root == NULL) root = getRlvShare();
+	LLStringUtil::toLower (catName);
+	std::deque<std::string> tokens = parse (catName, "&&");
+	
+	if (root) {
+		LLInventoryModel::cat_array_t* cats;
+		LLInventoryModel::item_array_t* items;
+		gInventory.getDirectDescendentsOf (root->getUUID(), cats, items);
+		
+		if(cats)
+		{
+			S32 count = cats->count();
+			LLInventoryCategory* cat = NULL;
+			
+			for(S32 i = 0; i < count; ++i)
+			{
+				cat = cats->get(i);
+				
+				// search deeper first
+				LLInventoryCategory* found = findCategoryUnderRlvShare (catName, cat);
+				if (found != NULL) return found;
+				
+			}
+		}
+		// return this category if it matches
+		std::string name = root->getName();
+		LLStringUtil::toLower (name);
+		if (name != "" && name[0] != '.' && findMultiple (tokens, name)) return root;
+	}
+	// didn't find anything
+	return NULL;
+}
+
+LLViewerJointAttachment* RRInterface::findAttachmentPointFromName (std::string objectName, BOOL exactName)
+{
+	BOOL debug = gSavedSettings.getBOOL("RestrainedLifeDebug");
+	// for each possible attachment point, check whether its name appears in the name of
+	// the item.
+	LLVOAvatar* avatar = gAgent.getAvatarObject();
+	LLStringUtil::toLower(objectName);
+	std::string attachName;
+	for (LLVOAvatar::attachment_map_t::iterator iter = avatar->mAttachmentPoints.begin(); 
+		 iter != avatar->mAttachmentPoints.end(); )
+	{
+		LLVOAvatar::attachment_map_t::iterator curiter = iter++;
+		LLViewerJointAttachment* attachment = curiter->second;
+		if (attachment) {
+			attachName = attachment->getName();
+			LLStringUtil::toLower(attachName);
+//			if (debug) {
+//				llinfos << "trying attachment " << attachName << llendl;
+//			}
+			if (exactName && objectName == attachName
+			 || !exactName && objectName.find (attachName) != -1)
+			{
+				// HACK : if we are on "top" or "bottom", check we are not actually wanting "top left" or "bottom right" respectively
+				// (if we didn't do that, we'd attach "top left" to "top" and "bottom righ" to "bottom")
+				if (!exactName && attachName == "top" && objectName.find ("top left") != -1) continue;
+				if (!exactName && attachName == "bottom" && objectName.find ("bottom right") != -1) continue;
+//				if (debug) {
+//					llinfos << "matched attachment " << attachName << llendl;
+//				}
+				return attachment;
+			}
+		}
+	}
+	if (debug) {
+		llinfos << "no attachment found" << llendl;
+	}
+	return NULL;
+}
+
+LLViewerJointAttachment* RRInterface::findAttachmentPointFromParentName (LLInventoryItem* item)
+{
+	if (item) {
+		// => look in parent folder (this could be a no-mod item), use its name to find the target
+		// attach point
+		LLViewerInventoryCategory* cat;
+		const LLUUID& parent_id = item->getParentUUID();
+		cat = gInventory.getCategory (parent_id);
+		return findAttachmentPointFromName (cat->getName());
+	}
+	return NULL;
+}
+
+S32 RRInterface::findAttachmentPointNumber (LLViewerJointAttachment* attachment)
+{
+	for (LLVOAvatar::attachment_map_t::iterator iter = gAgent.getAvatarObject()->mAttachmentPoints.begin();
+		 iter != gAgent.getAvatarObject()->mAttachmentPoints.end(); ++iter)
+	{
+		if (iter->second == attachment) {
+			return iter->first;
+		}
+	}
+	return -1;
+}
+
+void RRInterface::fetchInventory (LLInventoryCategory* root)
+{
+	// do this only once on login
+
+	if (sInventoryFetched) return;
+	
+	bool last_step = false;
+	
+	if (root == NULL) {
+		root = getRlvShare();
+		last_step = true;
+	}
+	
+	if (root) {
+		LLViewerInventoryCategory* viewer_root = (LLViewerInventoryCategory*) root;
+		viewer_root->fetchDescendents ();
+
+		LLInventoryModel::cat_array_t* cats;
+		LLInventoryModel::item_array_t* items;
+		
+		// retrieve all the shared folders
+		gInventory.getDirectDescendentsOf (viewer_root->getUUID(), cats, items);
+		if (cats) {
+			S32 count = cats->count();
+			for(S32 i = 0; i < count; ++i) {
+				LLInventoryCategory* cat = (LLInventoryCategory*)cats->get(i);
+				fetchInventory (cat);
+			}
+		}
+
+	}
+	
+	if (last_step) sInventoryFetched = TRUE;
+}
+
+void confirm_replace_attachment_rez(S32 option, void* user_data);
+
+BOOL RRInterface::forceAttach (std::string category, BOOL recursive /* = FALSE */)
+{
+	BOOL debug = gSavedSettings.getBOOL("RestrainedLifeDebug");
+	// find the category under RLV shared folder
+	LLInventoryCategory* cat = getCategoryUnderRlvShare (category);
+	BOOL isRoot = (getRlvShare() == cat);
+	
+	// if exists, wear all the items inside it
+	if (cat) {
+	
+		LLInventoryModel::cat_array_t* cats;
+		LLInventoryModel::item_array_t* items;
+		
+		// retrieve all the objects contained in this folder
+		gInventory.getDirectDescendentsOf (cat->getUUID(), cats, items);
+		if (items) {
+		
+			// wear them one by one
+			S32 count = items->count();
+			for(S32 i = 0; i < count; ++i) {
+				if (!isRoot) {
+					LLViewerInventoryItem* item = (LLViewerInventoryItem*)items->get(i);
+					if (debug) {
+						llinfos << "trying to attach " << item->getName() << llendl;
+					}
+					
+					// this is an object to attach somewhere
+					if (item && item->getType() == LLAssetType::AT_OBJECT) {
+						LLViewerJointAttachment* attachpt = findAttachmentPointFromName (item->getName());
+						
+						if (attachpt) {
+							if (debug) {
+								llinfos << "attaching item to " << attachpt->getName() << llendl;
+							}
+							// mimick rez_attachment without displaying an Xml alert to confirm
+							S32 number = findAttachmentPointNumber (attachpt);
+							LLAttachmentRezAction* rez_action = new LLAttachmentRezAction;
+							rez_action->mItemID = item->getUUID();
+							rez_action->mAttachPt = number;
+							if (attachpt->getObject()
+								&& isAllowed(attachpt->getObject()->getRootEdit()->getID(), "detach")
+							|| !attachpt->getObject())
+							{
+								confirm_replace_attachment_rez(0/*YES*/, (void*)rez_action);
+							}
+						}
+					
+					}
+					// this is a piece of clothing
+					else if (item->getType() == LLAssetType::AT_CLOTHING
+							 || item->getType() == LLAssetType::AT_BODYPART) {
+						wear_inventory_item_on_avatar (item);
+					}
+				}
+			}
+		}
+		
+		// scan every subfolder of the folder we are attaching, in order to attach no-mod items
+		if (cats) {
+		
+			// for each subfolder, attach the first item it contains according to its name
+			S32 count = cats->count();
+			for(S32 i = 0; i < count; ++i) {
+				LLViewerInventoryCategory* cat_child = (LLViewerInventoryCategory*)cats->get(i);
+				LLViewerJointAttachment* attachpt = findAttachmentPointFromName (cat_child->getName());
+				
+				if (attachpt && !isRoot) {
+					// this subfolder is properly named => attach the first item it contains
+					LLInventoryModel::cat_array_t* cats_grandchildren; // won't be used here
+					LLInventoryModel::item_array_t* items_grandchildren; // actual no-mod item(s)
+					gInventory.getDirectDescendentsOf (cat_child->getUUID(), 
+														cats_grandchildren, items_grandchildren);
+
+					if (items_grandchildren && items_grandchildren->count() == 1) {
+						LLViewerInventoryItem* item_grandchild = 
+								(LLViewerInventoryItem*)items_grandchildren->get(0);
+
+						if (item_grandchild && item_grandchild->getType() == LLAssetType::AT_OBJECT
+							&& !item_grandchild->getPermissions().allowModifyBy(gAgent.getID())
+							&& findAttachmentPointFromParentName (item_grandchild) != NULL) { // it is no-mod and its parent is named correctly
+							// we use the attach point from the name of the folder, not the no-mod item
+							// mimick rez_attachment without displaying an Xml alert to confirm
+							S32 number = findAttachmentPointNumber (attachpt);
+							LLAttachmentRezAction* rez_action = new LLAttachmentRezAction;
+							rez_action->mItemID = item_grandchild->getUUID();
+							rez_action->mAttachPt = number;
+							if (attachpt->getObject()
+								&& isAllowed(attachpt->getObject()->getRootEdit()->getID(), "detach")
+							|| !attachpt->getObject())
+							{
+								confirm_replace_attachment_rez(0/*YES*/, (void*)rez_action);
+							}
+							
+						}
+					}
+				}
+				if (recursive && cat_child->getName().find (".") != 0) { // attachall and not invisible)
+					forceAttach (getFullPath (cat_child), recursive);
+				}
+			}
+		}
+	}
+	return TRUE;
+}
+
+BOOL RRInterface::forceDetachByName (std::string category, BOOL recursive /* = FALSE */)
+{
+	BOOL debug = gSavedSettings.getBOOL("RestrainedLifeDebug");
+	// find the category under RLV shared folder
+	LLInventoryCategory* cat = getCategoryUnderRlvShare (category);
+	LLVOAvatar* avatar = gAgent.getAvatarObject();
+	BOOL isRoot = (getRlvShare() == cat);
+	
+	// if exists, detach/unwear all the items inside it
+	if (cat) {
+	
+		LLInventoryModel::cat_array_t* cats;
+		LLInventoryModel::item_array_t* items;
+		
+		// retrieve all the objects contained in this folder
+		gInventory.getDirectDescendentsOf (cat->getUUID(), cats, items);
+		if (items) {
+		
+			// unwear them one by one
+			S32 count = items->count();
+			for(S32 i = 0; i < count; ++i) {
+				if (!isRoot) {
+					LLViewerInventoryItem* item = (LLViewerInventoryItem*)items->get(i);
+					if (debug) {
+						llinfos << "trying to detach " << item->getName() << llendl;
+					}
+					
+					// attached object
+					if (item->getType() == LLAssetType::AT_OBJECT) {
+						// find the attachpoint from which to detach
+						for (LLVOAvatar::attachment_map_t::iterator iter = avatar->mAttachmentPoints.begin(); 
+							 iter != avatar->mAttachmentPoints.end(); )
+						{
+							LLVOAvatar::attachment_map_t::iterator curiter = iter++;
+							LLViewerJointAttachment* attachment = curiter->second;
+							
+							if (attachment->getObject()) {
+								if (attachment->getItemID() == item->getUUID()) {
+									handle_detach_from_avatar ((void*)attachment);
+									break;
+								}
+							}
+						}
+						
+					}
+					// piece of clothing
+					else if (item->getType() == LLAssetType::AT_CLOTHING) {
+						LLWearable* layer = gAgent.getWearableFromWearableItem (item->getUUID());
+						if (layer != NULL) gAgent.removeWearable (layer->getType());
+						
+					}
+				}
+			}
+		}
+		
+		if (cats) {
+			// for each subfolder, detach the first item it contains (only for single no-mod items contained in appropriately named folders)
+			S32 count = cats->count();
+			for(S32 i = 0; i < count; ++i) {
+				LLViewerInventoryCategory* cat_child = (LLViewerInventoryCategory*)cats->get(i);
+				LLInventoryModel::cat_array_t* cats_grandchildren; // won't be used here
+				LLInventoryModel::item_array_t* items_grandchildren; // actual no-mod item(s)
+				gInventory.getDirectDescendentsOf (cat_child->getUUID(), 
+													cats_grandchildren, items_grandchildren);
+
+				if (!isRoot && items_grandchildren && items_grandchildren->count() == 1) { // only one item
+					LLViewerInventoryItem* item_grandchild = 
+							(LLViewerInventoryItem*)items_grandchildren->get(0);
+
+					if (item_grandchild && item_grandchild->getType() == LLAssetType::AT_OBJECT
+						&& !item_grandchild->getPermissions().allowModifyBy(gAgent.getID())
+						&& findAttachmentPointFromParentName (item_grandchild) != NULL) { // and it is no-mod and its parent is named correctly
+						// detach this object
+						// find the attachpoint from which to detach
+						for (LLVOAvatar::attachment_map_t::iterator iter = avatar->mAttachmentPoints.begin(); 
+							 iter != avatar->mAttachmentPoints.end(); )
+						{
+							LLVOAvatar::attachment_map_t::iterator curiter = iter++;
+							LLViewerJointAttachment* attachment = curiter->second;
+							
+							if (attachment->getObject()) {
+								if (attachment->getItemID() == item_grandchild->getUUID()) {
+									handle_detach_from_avatar ((void*)attachment);
+									break;
+								}
+							}
+						}
+					}
+				}
+
+				if (recursive && cat_child->getName().find (".") != 0) { // detachall and not invisible)
+					forceDetachByName (getFullPath (cat_child), recursive);
+				}
+			}
+		}
+	}
+	return TRUE;
+}
+
+BOOL RRInterface::forceTeleport (std::string location)
+{
+	BOOL debug = gSavedSettings.getBOOL("RestrainedLifeDebug");
+	// location must be X/Y/Z where X, Y and Z are ABSOLUTE coordinates => use a script in-world to translate from local to global
+	std::string loc (location);
+	std::string region_name;
+	S32 x = 128;
+	S32 y = 128;
+	S32 z = 0;
+	std::deque<std::string> tokens=parse (location, "/");
+	if (tokens.size()==3) {
+		x=atoi (tokens.at(0).c_str());
+		y=atoi (tokens.at(1).c_str());
+		z=atoi (tokens.at(2).c_str());
+	}
+	else {
+		return FALSE;
+	}
+
+	if (debug) {
+		llinfos << tokens.at(0) << "," << tokens.at(1) << "," << tokens.at(2) << "     " << x << "," << y << "," << z << llendl;
+	}
+	LLVector3d pos_global;
+	pos_global.mdV[VX] = (F32)x;
+	pos_global.mdV[VY] = (F32)y;
+	pos_global.mdV[VZ] = (F32)z;
+	
+	sAllowCancelTp = FALSE; // will be checked once receiving the tp order from the sim, then set to TRUE again
+
+	gAgent.teleportViaLocation (pos_global);
+	return TRUE;
+}
+
+std::string RRInterface::stringReplace (std::string s, std::string what, std::string by, BOOL caseSensitive /* = FALSE */)
+{
+//	llinfos << "trying to replace <" << what << "> in <" << s << "> by <" << by << ">" << llendl;
+	if (what == "" || what == " ") return s; // avoid an infinite loop
+	int ind;
+	int old_ind = 0;
+	int len_what = what.length();
+	int len_by = by.length();
+	if (len_by == 0) len_by = 1; // avoid an infinite loop
+	
+	while ((ind = s.find ("%20")) != -1) // unescape
+	{
+		s = s.replace (ind, 3, " ");
+	}
+	
+	std::string lower = s;
+	if (!caseSensitive) {
+		LLStringUtil::toLower (lower);
+		LLStringUtil::toLower (what);
+	}
+	
+	while ((ind = lower.find (what, old_ind)) != -1)
+	{
+//		llinfos << "ind=" << ind << "    old_ind=" << old_ind << llendl;
+		s = s.replace (ind, len_what, by);
+		old_ind = ind + len_by;
+		lower = s;
+		if (!caseSensitive) LLStringUtil::toLower (lower);
+	}
+	return s;
+	
+}
+
+std::string RRInterface::getDummyName (std::string name, EChatAudible audible /* = CHAT_AUDIBLE_FULLY */)
+{
+	int len = name.length();
+	if (len < 2) return ""; // just to avoid crashing in some cases
+	char hash = name.at(3) + len; // very lame hash function I know... but it should be linear enough (the old length method was way too gaussian with a peak at 11 to 16 characters)
+	char mod = hash % 28;
+	std::string res = "";
+	switch (mod) {
+		case 0:		res = "A resident";			break;
+		case 1:		res = "This resident";		break;
+		case 2:		res = "That resident";		break;
+		case 3:		res = "An individual";		break;
+		case 4:		res = "This individual";	break;
+		case 5:		res = "That individual";	break;
+		case 6:		res = "A person";			break;
+		case 7:		res = "This person";		break;
+		case 8:		res = "That person";		break;
+		case 9:		res = "A stranger";			break;
+		case 10:	res = "This stranger";		break;
+		case 11:	res = "That stranger";		break;
+		case 12:	res = "A human being";		break;
+		case 13:	res = "This human being";	break;
+		case 14:	res = "That human being";	break;
+		case 15:	res = "An agent";			break;
+		case 16:	res = "This agent";			break;
+		case 17:	res = "That agent";			break;
+		case 18:	res = "A soul";				break;
+		case 19:	res = "This soul";			break;
+		case 20:	res = "That soul";			break;
+		case 21:	res = "Somebody";			break;
+		case 22:	res = "Some people";		break;
+		case 23:	res = "Someone";			break;
+		case 24:	res = "Mysterious one";		break;
+		case 25:	res = "An unknown being";	break;
+		case 26:	res = "Unidentified one";	break;
+		default:	res = "An unknown person";	break;
+	}
+	if (audible == CHAT_AUDIBLE_BARELY) res += " afar";
+	return res;
+}
+
+std::string RRInterface::getCensoredMessage (std::string str)
+{
+	// Hide every occurrence of the name of anybody around (found in cache, so not completely accurate nor completely immediate)
+	S32 i;
+	for (i=0; i<gObjectList.getNumObjects(); ++i) {
+		LLViewerObject* object = gObjectList.getObject(i);
+		if (object) {
+			std::string name;
+			std::string dummy_name;
+			
+			if (object->isAvatar()) {
+				if (gCacheName->getFullName (object->getID(), name)) {
+					dummy_name = getDummyName (name);
+					str = stringReplace (str,
+						name, dummy_name); // full name first
+//					str = stringReplace (str,
+//						 getFirstName (name), dummy_name); // first name
+//					str = stringReplace (str,
+//						 getLastName (name), dummy_name); // last name
+				}
+			}
+		}
+	}
+	return str;
+}
+
+void updateAndSave (WLColorControl* color)
+{
+	if (color == NULL) return;
+	color->i = color->r;
+	if (color->g > color->i) {
+		color->i = color->g;
+	}
+	if (color->b > color->i) {
+		color->i = color->b;
+	}
+	color->update (LLWLParamManager::instance()->mCurParams);
+}
+
+void updateAndSave (WLFloatControl* floatControl)
+{
+	if (floatControl == NULL) return;
+	floatControl->update (LLWLParamManager::instance()->mCurParams);
+}
+
+BOOL RRInterface::forceEnvironment (std::string command, std::string option)
+{
+	// command is "setenv_<something>"
+	double val = atof (option.c_str());
+
+	int length = 7; // size of "setenv_"
+	command = command.substr (length);
+	LLWLParamManager* params = LLWLParamManager::instance();
+
+	params->mAnimator.mIsRunning = false;
+	params->mAnimator.mUseLindenTime = false;
+
+	if (command == "daytime") {
+		if (val > 1.0) val = 1.0;
+		if (val >= 0.0) {
+			params->mAnimator.setDayTime(val);
+			params->mAnimator.update(params->mCurParams);
+		}
+		else {
+			LLWLParamManager::instance()->mAnimator.mIsRunning = true;
+			LLWLParamManager::instance()->mAnimator.mUseLindenTime = true;
+		}
+	}
+	else if (command == "bluehorizonr") {
+		params->mBlueHorizon.r = val*2;
+		updateAndSave (&(params->mBlueHorizon));
+	}
+	else if (command == "bluehorizong") {
+		params->mBlueHorizon.g = val*2;
+		updateAndSave (&(params->mBlueHorizon));
+	}
+	else if (command == "bluehorizonb") {
+		params->mBlueHorizon.b = val*2;
+		updateAndSave (&(params->mBlueHorizon));
+	}
+	else if (command == "bluehorizoni") {
+		params->mBlueHorizon.r = val*2;
+		params->mBlueHorizon.g = val*2;
+		params->mBlueHorizon.b = val*2;
+		updateAndSave (&(params->mBlueHorizon));
+	}
+
+	else if (command == "bluedensityr") {
+		params->mBlueDensity.r = val*2;
+		updateAndSave (&(params->mBlueDensity));
+	}
+	else if (command == "bluedensityg") {
+		params->mBlueDensity.g = val*2;
+		updateAndSave (&(params->mBlueDensity));
+	}
+	else if (command == "bluedensityb") {
+		params->mBlueDensity.b = val*2;
+		updateAndSave (&(params->mBlueDensity));
+	}
+	else if (command == "bluedensityi") {
+		params->mBlueDensity.r = val*2;
+		params->mBlueDensity.g = val*2;
+		params->mBlueDensity.b = val*2;
+		updateAndSave (&(params->mBlueDensity));
+	}
+
+	else if (command == "hazehorizon") {
+		params->mHazeHorizon.r = val*2;
+		params->mHazeHorizon.g = val*2;
+		params->mHazeHorizon.b = val*2;
+		updateAndSave (&(params->mHazeHorizon));
+	}
+	else if (command == "hazedensity") {
+		params->mHazeDensity.r = val*2;
+		params->mHazeDensity.g = val*2;
+		params->mHazeDensity.b = val*2;
+		updateAndSave (&(params->mHazeDensity));
+	}
+
+	else if (command == "densitymultiplier") {
+		params->mDensityMult.x = val/1000;
+		updateAndSave (&(params->mDensityMult));
+		LLWaterParamManager* water_params = LLWaterParamManager::instance();
+		water_params->mFogDensity.mExp = 5.0;
+		water_params->mFogDensity.update (water_params->mCurParams);
+	}
+	else if (command == "distancemultiplier") {
+		params->mDistanceMult.x = val;
+		updateAndSave (&(params->mDistanceMult));
+		LLWaterParamManager* water_params = LLWaterParamManager::instance();
+		water_params->mUnderWaterFogMod.mX = 1.0;
+		water_params->mUnderWaterFogMod.update (water_params->mCurParams);
+	}
+	else if (command == "maxaltitude") {
+		params->mMaxAlt.x = val;
+		updateAndSave (&(params->mMaxAlt));
+	}
+
+	else if (command == "sunmooncolorr") {
+		params->mSunlight.r = val*3;
+		updateAndSave (&(params->mSunlight));
+	}
+	else if (command == "sunmooncolorg") {
+		params->mSunlight.g = val*3;
+		updateAndSave (&(params->mSunlight));
+	}
+	else if (command == "sunmooncolorb") {
+		params->mSunlight.b = val*3;
+		updateAndSave (&(params->mSunlight));
+	}
+	else if (command == "sunmooncolori") {
+		params->mSunlight.r = val*3;
+		params->mSunlight.g = val*3;
+		params->mSunlight.b = val*3;
+		updateAndSave (&(params->mSunlight));
+	}
+
+	else if (command == "ambientr") {
+		params->mAmbient.r = val*3;
+		updateAndSave (&(params->mAmbient));
+	}
+	else if (command == "ambientg") {
+		params->mAmbient.g = val*3;
+		updateAndSave (&(params->mAmbient));
+	}
+	else if (command == "ambientb") {
+		params->mAmbient.b = val*3;
+		updateAndSave (&(params->mAmbient));
+	}
+	else if (command == "ambienti") {
+		params->mAmbient.r = val*3;
+		params->mAmbient.g = val*3;
+		params->mAmbient.b = val*3;
+		updateAndSave (&(params->mAmbient));
+	}
+	else if (command == "sunglowfocus") {
+		params->mGlow.b = -val*5;
+		updateAndSave (&(params->mGlow));
+	}
+	else if (command == "sunglowsize") {
+		params->mGlow.r = (2-val)*20;
+		updateAndSave (&(params->mGlow));
+	}
+	else if (command == "scenegamma") {
+		params->mWLGamma.x = val;
+		updateAndSave (&(params->mWLGamma));
+	}
+	else if (command == "sunmoonposition") {
+		params->mCurParams.setSunAngle (F_TWO_PI * val);
+	}
+	else if (command == "eastangle") {
+		params->mCurParams.setEastAngle (F_TWO_PI * val);
+	}
+	else if (command == "starbrightness") {
+		params->mCurParams.setStarBrightness (val);
+	}
+
+	else if (command == "cloudcolorr") {
+		params->mCloudColor.r = val;
+		updateAndSave (&(params->mCloudColor));
+	}
+	else if (command == "cloudcolorg") {
+		params->mCloudColor.g = val;
+		updateAndSave (&(params->mCloudColor));
+	}
+	else if (command == "cloudcolorb") {
+		params->mCloudColor.b = val;
+		updateAndSave (&(params->mCloudColor));
+	}
+	else if (command == "cloudcolori") {
+		params->mCloudColor.r = val;
+		params->mCloudColor.g = val;
+		params->mCloudColor.b = val;
+		updateAndSave (&(params->mCloudColor));
+	}
+
+	else if (command == "cloudx") {
+		params->mCloudMain.r = val;
+		updateAndSave (&(params->mCloudMain));
+	}
+	else if (command == "cloudy") {
+		params->mCloudMain.g = val;
+		updateAndSave (&(params->mCloudMain));
+	}
+	else if (command == "cloudd") {
+		params->mCloudMain.b = val;
+		updateAndSave (&(params->mCloudMain));
+	}
+
+	else if (command == "clouddetailx") {
+		params->mCloudDetail.r = val;
+		updateAndSave (&(params->mCloudDetail));
+	}
+	else if (command == "clouddetaily") {
+		params->mCloudDetail.g = val;
+		updateAndSave (&(params->mCloudDetail));
+	}
+	else if (command == "clouddetaild") {
+		params->mCloudDetail.b = val;
+		updateAndSave (&(params->mCloudDetail));
+	}
+
+	else if (command == "cloudcoverage") {
+		params->mCloudCoverage.x = val;
+		updateAndSave (&(params->mCloudCoverage));
+	}
+	else if (command == "cloudscale") {
+		params->mCloudScale.x = val;
+		updateAndSave (&(params->mCloudScale));
+	}
+
+	else if (command == "cloudscrollx") {
+		params->mCurParams.setCloudScrollX (val+10);
+	}
+	else if (command == "cloudscrolly") {
+		params->mCurParams.setCloudScrollY (val+10);
+	}
+	// sunglowfocus 0-0.5, sunglowsize 0-2, scenegamma 0-10, starbrightness 0-2
+	// cloudcolor rgb 0-1, cloudxydensity xyd 0-1, cloudcoverage 0-1, cloudscale 0-1, clouddetail xyd 0-1
+	// cloudscrollx 0-1, cloudscrolly 0-1, drawclassicclouds 0/1
+
+	else if (command == "preset") {
+		params->loadPreset (option);
+	}
+
+	// send the current parameters to shaders
+	LLWLParamManager::instance()->propagateParameters();
+
+	return TRUE;
+}
+
+std::string RRInterface::getEnvironment (std::string command)
+{
+	F64 res = 0;
+	int length = 7; // size of "getenv_"
+	command = command.substr (length);
+	LLWLParamManager* params = LLWLParamManager::instance();
+
+	if (command == "daytime") {
+		if (params->mAnimator.mIsRunning && params->mAnimator.mUseLindenTime) res = -1;
+		else res = params->mAnimator.getDayTime();
+	}
+
+	else if (command == "bluehorizonr") res = params->mBlueHorizon.r/2;
+	else if (command == "bluehorizong") res = params->mBlueHorizon.g/2;
+	else if (command == "bluehorizonb") res = params->mBlueHorizon.b/2;
+	else if (command == "bluehorizoni") res = max (max (params->mBlueHorizon.r, params->mBlueHorizon.g), params->mBlueHorizon.b) / 2;
+
+	else if (command == "bluedensityr") res = params->mBlueDensity.r/2;
+	else if (command == "bluedensityg") res = params->mBlueDensity.g/2;
+	else if (command == "bluedensityb") res = params->mBlueDensity.b/2;
+	else if (command == "bluedensityi") res = max (max (params->mBlueDensity.r, params->mBlueDensity.g), params->mBlueDensity.b) / 2;
+
+	else if (command == "hazehorizon")  res = max (max (params->mHazeHorizon.r, params->mHazeHorizon.g), params->mHazeHorizon.b) / 2;
+	else if (command == "hazedensity")  res = max (max (params->mHazeDensity.r, params->mHazeDensity.g), params->mHazeDensity.b) / 2;
+
+	else if (command == "densitymultiplier")  res = params->mDensityMult.x*1000;
+	else if (command == "distancemultiplier") res = params->mDistanceMult.x;
+	else if (command == "maxaltitude")        res = params->mMaxAlt.x;
+
+	else if (command == "sunmooncolorr") res = params->mSunlight.r/3;
+	else if (command == "sunmooncolorg") res = params->mSunlight.g/3;
+	else if (command == "sunmooncolorb") res = params->mSunlight.b/3;
+	else if (command == "sunmooncolori") res = max (max (params->mSunlight.r, params->mSunlight.g), params->mSunlight.b) / 3;
+
+	else if (command == "ambientr") res = params->mAmbient.r/3;
+	else if (command == "ambientg") res = params->mAmbient.g/3;
+	else if (command == "ambientb") res = params->mAmbient.b/3;
+	else if (command == "ambienti") res = max (max (params->mAmbient.r, params->mAmbient.g), params->mAmbient.b) / 3;
+
+	else if (command == "sunglowfocus")	res = -params->mGlow.b/5;
+	else if (command == "sunglowsize")		res = 2-params->mGlow.r/20;
+	else if (command == "scenegamma")		res = params->mWLGamma.x;
+
+	else if (command == "sunmoonposition")		res = params->mCurParams.getSunAngle()/F_TWO_PI;
+	else if (command == "eastangle")			res = params->mCurParams.getEastAngle()/F_TWO_PI;
+	else if (command == "starbrightness")		res = params->mCurParams.getStarBrightness();
+
+	else if (command == "cloudcolorr") res = params->mCloudColor.r;
+	else if (command == "cloudcolorg") res = params->mCloudColor.g;
+	else if (command == "cloudcolorb") res = params->mCloudColor.b;
+	else if (command == "cloudcolori") res = max (max (params->mCloudColor.r, params->mCloudColor.g), params->mCloudColor.b);
+
+	else if (command == "cloudx")  res = params->mCloudMain.r;
+	else if (command == "cloudy")  res = params->mCloudMain.g;
+	else if (command == "cloudd")  res = params->mCloudMain.b;
+
+	else if (command == "clouddetailx")  res = params->mCloudDetail.r;
+	else if (command == "clouddetaily")  res = params->mCloudDetail.g;
+	else if (command == "clouddetaild")  res = params->mCloudDetail.b;
+
+	else if (command == "cloudcoverage")	res = params->mCloudCoverage.x;
+	else if (command == "cloudscale")		res = params->mCloudScale.x;
+
+	else if (command == "cloudscrollx") res = params->mCurParams.getCloudScrollX() - 10;
+	else if (command == "cloudscrolly") res = params->mCurParams.getCloudScrollY() - 10;
+
+	else if (command == "preset") return getLastLoadedPreset();
+
+	std::stringstream str;
+	str << res;
+	return str.str();
+}
+
+BOOL RRInterface::forceDebugSetting (std::string command, std::string option)
+{
+	//	MK: As some debug settings are critical to the user's experience and others
+	//	are just useless/not used, we are following a whitelist approach : only allow
+	//	certain debug settings to be changed and not all.
+	
+	// command is "setdebug_<something>"
+	
+	int length = 9; // size of "setdebug_"
+	command = command.substr (length);
+	LLStringUtil::toLower(command);
+	std::string allowed;
+	std::string tmp;
+	int ind;
+	
+	allowed = sAllowedU32;
+	tmp = allowed;
+	LLStringUtil::toLower(tmp);
+	if ((ind = tmp.find (","+command+",")) != -1) {
+		gSavedSettings.setU32 (allowed.substr(++ind, command.length()), atoi(option.c_str()));
+		return TRUE;
+	}
+	
+	return TRUE;
+}
+
+std::string RRInterface::getDebugSetting (std::string command)
+{
+	std::stringstream res;
+	int length = 9; // size of "getdebug_"
+	command = command.substr (length);
+	LLStringUtil::toLower(command);
+	std::string allowed;
+	std::string tmp;
+	int ind;
+	
+	allowed = sAllowedU32;
+	tmp = allowed;
+	LLStringUtil::toLower(tmp);
+	if ((ind = tmp.find (","+command+",")) != -1) {
+		res << gSavedSettings.getU32 (allowed.substr(++ind, command.length()));
+		return res.str();
+	}
+	
+	return res.str();
+}
+
+std::string RRInterface::getFullPath (LLInventoryCategory* cat)
+{
+	if (cat == NULL) return "";
+	LLInventoryCategory* rlv = gAgent.mRRInterface.getRlvShare();
+	if (rlv == NULL) return "";
+	LLInventoryCategory* res = cat;
+	std::deque<std::string> tokens;
+	
+	while (res && res != rlv) {
+		tokens.push_front (res->getName());
+		const LLUUID& parent_id = res->getParentUUID();
+		res = gInventory.getCategory (parent_id);
+	}
+	return dumpList2String (tokens, "/");
+}
+
+std::string RRInterface::getFullPath (LLInventoryItem* item, std::string option)
+{
+	// Returns the path from the shared root to this object, or to the object worn at the attach point or clothing layer pointed by option if any
+	if (option != "") {
+		item = NULL; // an option is specified => we don't want to check the item that issued the command, but something else that is currently worn (object or clothing)
+		
+		EWearableType wearable_type = gAgent.mRRInterface.getOutfitLayerAsType (option);
+		if (wearable_type != WT_INVALID) { // this is a clothing layer => replace item with the piece clothing
+			LLUUID id = gAgent.getWearableItem (wearable_type);
+			if (id.notNull()) item = gInventory.getItem(id);
+			if (item != NULL && !gAgent.mRRInterface.isUnderRlvShare(item)) item = NULL; // security : we would return the path even if the item was not shared otherwise
+		}
+		else { // this is not a clothing layer => it has to be an attachment point
+			LLViewerJointAttachment* attach_point = gAgent.mRRInterface.findAttachmentPointFromName (option, TRUE);
+			if (attach_point) {
+				LLViewerObject* attached_object = attach_point->getObject();
+				item = getItemAux (attached_object, gAgent.mRRInterface.getRlvShare());
+				if (item != NULL && !gAgent.mRRInterface.isUnderRlvShare(item)) item = NULL; // security : we would return the path even if the item was not shared otherwise
+			}
+		}
+	}
+	
+	if (item != NULL && !gAgent.mRRInterface.isUnderRlvShare(item)) item = NULL; // security : we would return the path even if the item was not shared otherwise
+	if (item == NULL) return "";
+	LLUUID parent_id = item->getParentUUID();
+	LLInventoryCategory* parent_cat = gInventory.getCategory (parent_id);
+	
+	if (item->getType() == LLAssetType::AT_OBJECT && !item->getPermissions().allowModifyBy(gAgent.getID())) {
+		if (gAgent.mRRInterface.findAttachmentPointFromName(parent_cat->getName()) != NULL) {
+			// this item is no-mod and its parent folder contains the name of an attach point
+			// => probably we want the full path only to the containing folder of that folder
+			parent_id = parent_cat->getParentUUID();
+			parent_cat = gInventory.getCategory (parent_id);
+			return getFullPath (parent_cat);
+		}
+	}
+	
+	return getFullPath (parent_cat);
+}
+
+
+LLInventoryItem* RRInterface::getItemAux (LLViewerObject* attached_object, LLInventoryCategory* root)
+{
+	// auxiliary function for getItem()
+	if (!attached_object) return NULL;
+	LLVOAvatar* avatar = gAgent.getAvatarObject();
+	if (root && avatar) {
+		LLInventoryModel::cat_array_t* cats;
+		LLInventoryModel::item_array_t* items;
+		gInventory.getDirectDescendentsOf (root->getUUID(), cats, items);
+		S32 count;
+		S32 i;
+		LLInventoryItem* item = NULL;
+		LLInventoryCategory* cat = NULL;
+		
+		// Try to find the item in the current category
+		count = items->count();
+		for(i = 0; i < count; ++i) {
+			item = items->get(i);
+			if (item 
+				&& (item->getType() == LLAssetType::AT_OBJECT || item->getType() == LLAssetType::AT_CLOTHING)
+				&& avatar->getWornAttachment (item->getUUID()) == attached_object
+				) {
+				// found the item in the current category
+				return item;
+			}
+		}
+		
+		// We didn't find it here => browse the children categories
+		count = cats->count();
+		for(i = 0; i < count; ++i) {
+			cat = cats->get(i);
+			item = getItemAux (attached_object, cat);
+			if (item != NULL) return item;
+		}
+	}
+	// We didn't find it (this should not happen)
+	return NULL;
+}
+
+LLInventoryItem* RRInterface::getItem (LLUUID wornObjectUuidInWorld)
+{
+	// return the inventory item corresponding to the viewer object which UUID is "wornObjectUuidInWorld", if any
+	LLViewerObject* object = gObjectList.findObject (wornObjectUuidInWorld);
+	if (object != NULL) {
+		if (object->isAttachment()) {
+			return getItemAux (object, gInventory.getCategory(gInventory.findCategoryUUIDForType(LLAssetType::AT_CATEGORY))); //gAgent.mRRInterface.getRlvShare());
+		}
+	}
+	// This object is not worn => it has nothing to do with any inventory item
+	return NULL;
+}
+
+void RRInterface::attachObjectByUUID (LLUUID assetUUID, int attachPtNumber)
+{
+	// caution : this method does NOT check that the target attach point is already used by a locked item
+	LLAttachmentRezAction* rez_action = new LLAttachmentRezAction;
+	rez_action->mItemID = assetUUID;
+	rez_action->mAttachPt = attachPtNumber;
+	confirm_replace_attachment_rez(0/*YES*/, (void*)rez_action);
+}
diff -urN linden/indra/newview/RRInterface.h linden-patched/indra/newview/RRInterface.h
--- linden/indra/newview/RRInterface.h	1970-01-01 01:00:00.000000000 +0100
+++ linden-patched/indra/newview/RRInterface.h	2009-03-16 19:34:42.000000000 +0100
@@ -0,0 +1,170 @@
+#ifndef LL_RRINTERFACE_H
+#define LL_RRINTERFACE_H
+
+#define RR_PREFIX "@"
+#define RR_VERSION "1.16d"
+
+#define RR_SHARED_FOLDER "#RLV"
+#define RR_SHARED_FOLDER_WITH_SEPARATOR "#RLV/"
+// Length of the above string constant in characters.
+#define RR_SFWS_LENGTH 5
+
+// wearable types as strings
+#define WS_ALL "all"
+#define WS_EYES "eyes"
+#define WS_SKIN "skin"
+#define WS_SHAPE "shape"
+#define WS_HAIR "hair"
+#define WS_GLOVES "gloves"
+#define WS_JACKET "jacket"
+#define WS_PANTS "pants"
+#define WS_SHIRT "shirt"
+#define WS_SHOES "shoes"
+#define WS_SKIRT "skirt"
+#define WS_SOCKS "socks"
+#define WS_UNDERPANTS "underpants"
+#define WS_UNDERSHIRT "undershirt"
+
+
+//#include <set>
+#include <deque>
+#include <map>
+#include <string>
+
+#include "lluuid.h"
+#include "llchat.h"
+#include "llchatbar.h"
+#include "llinventorymodel.h"
+#include "llviewermenu.h"
+#include "llwearable.h"
+
+typedef std::multimap<std::string, std::string> RRMAP;
+typedef struct Command {
+	LLUUID uuid;
+	std::string command;
+} Command;
+
+class RRInterface
+{
+public:
+	
+	RRInterface ();
+	~RRInterface ();
+
+	std::string getVersion ();
+	BOOL isAllowed (LLUUID object_uuid, std::string action, BOOL log_it = TRUE);
+	BOOL contains (std::string action);
+	BOOL containsSubstr (std::string action);
+
+	BOOL add (LLUUID object_uuid, std::string action, std::string option);
+	BOOL remove (LLUUID object_uuid, std::string action, std::string option);
+	BOOL clear (LLUUID object_uuid, std::string command="");
+	BOOL garbageCollector (BOOL all=TRUE); // if false, don't clear rules attached to NULL_KEY as they are issued from external objects (only cleared when changing parcel)
+	std::deque<std::string> parse (std::string str, std::string sep); // utility function
+
+	BOOL parseCommand (std::string command, std::string& behaviour, std::string& option, std::string& param);
+	BOOL handleCommand (LLUUID uuid, std::string command);
+	BOOL fireCommands (); // execute commands buffered while the viewer was initializing (mostly useful for force-sit as when the command is sent the object is not necessarily rezzed yet)
+	BOOL force (LLUUID object_uuid, std::string command, std::string option);
+
+	BOOL answerOnChat (std::string channel, std::string msg);
+	std::string crunchEmote (std::string msg, unsigned int truncateTo);
+
+	std::string getOutfitLayerAsString (EWearableType layer);
+	EWearableType getOutfitLayerAsType (std::string layer);
+	std::string getOutfit (std::string layer);
+	std::string getAttachments (std::string attachpt);
+
+	std::string getStatus (LLUUID object_uuid, std::string rule); // if object_uuid is null, return all
+	BOOL forceDetach (std::string attachpt);
+
+	BOOL hasLockedHuds ();
+	std::string getInventoryList (std::string path, BOOL withWornInfo = FALSE);
+	std::string getWornItems (LLInventoryCategory* cat);
+	LLInventoryCategory* getRlvShare (); // return pointer to #RLV folder or null if does not exist
+	BOOL isUnderRlvShare (LLInventoryItem* item);
+	void renameAttachment (LLInventoryItem* item, LLViewerJointAttachment* attachment); // DEPRECATED
+	LLInventoryCategory* getCategoryUnderRlvShare (std::string catName, LLInventoryCategory* root = NULL);
+	LLInventoryCategory* findCategoryUnderRlvShare (std::string catName, LLInventoryCategory* root = NULL);
+	LLViewerJointAttachment* findAttachmentPointFromName (std::string objectName, BOOL exactName = FALSE);
+	LLViewerJointAttachment* findAttachmentPointFromParentName (LLInventoryItem* item);
+	S32 findAttachmentPointNumber (LLViewerJointAttachment* attachment);
+	void fetchInventory (LLInventoryCategory* root = NULL);
+
+	BOOL forceAttach (std::string category, BOOL recursive = FALSE);
+	BOOL forceDetachByName (std::string category, BOOL recursive = FALSE);
+
+	BOOL getAllowCancelTp() { return sAllowCancelTp; }
+	void setAllowCancelTp(BOOL newval) { sAllowCancelTp = newval; }
+
+	std::string getParcelName () { return sParcelName; }
+	void setParcelName (std::string newval) { sParcelName = newval; }
+
+	BOOL forceTeleport (std::string location);
+
+	std::string stringReplace (std::string s, std::string what, std::string by, BOOL caseSensitive = FALSE);
+
+	std::string getDummyName (std::string name, EChatAudible audible = CHAT_AUDIBLE_FULLY); // return "someone", "unknown" etc according to the length of the name (when shownames is on)
+	std::string getCensoredMessage (std::string str); // replace names by dummy names
+
+	LLUUID getSitTargetId () { return sSitTargetId; }
+	void setSitTargetId (LLUUID newval) { sSitTargetId = newval; }
+
+	BOOL forceEnvironment (std::string command, std::string option); // command is "setenv_<something>", option is a list of floats (separated by "/")
+	std::string getEnvironment (std::string command); // command is "getenv_<something>"
+	
+	std::string getLastLoadedPreset () { return sLastLoadedPreset; }
+	void setLastLoadedPreset (std::string newval) { sLastLoadedPreset = newval; }
+
+	BOOL forceDebugSetting (std::string command, std::string option); // command is "setdebug_<something>", option is a list of values (separated by "/")
+	std::string getDebugSetting (std::string command); // command is "getdebug_<something>"
+
+	std::string getFullPath (LLInventoryCategory* cat);
+	std::string getFullPath (LLInventoryItem* item, std::string option = "");
+	LLInventoryItem* getItemAux (LLViewerObject* attached_object, LLInventoryCategory* root);
+	LLInventoryItem* getItem (LLUUID wornObjectUuidInWorld);
+	void attachObjectByUUID (LLUUID assetUUID, int attachPtNumber = 0);
+
+	// Some cache variables to accelerate common checks
+	BOOL mContainsDetach;
+	BOOL mContainsShowinv;
+	BOOL mContainsUnsit;
+	BOOL mContainsFartouch;
+	BOOL mContainsShowloc;
+	BOOL mContainsShownames;
+	BOOL mContainsSetenv;
+	BOOL mContainsFly;
+	BOOL mContainsEdit;
+	BOOL mContainsRez;
+
+	// Allowed debug settings (initialized in the ctor)
+	std::string sAllowedU32;
+	std::string sAllowedS32;
+	std::string sAllowedF32;
+	std::string sAllowedBOOLEAN;
+	std::string sAllowedSTRING;
+	std::string sAllowedVEC3;
+	std::string sAllowedVEC3D;
+	std::string sAllowedRECT;
+	std::string sAllowedCOL4;
+	std::string sAllowedCOL3;
+	std::string sAllowedCOL4U;
+	
+	// These should be private but we may want to browse them from the outside world, so let's keep them public
+	RRMAP sSpecialObjectBehaviours;
+	std::deque<Command> sRetainedCommands;
+
+	// When a locked attachment is kicked off by another one with llAttachToAvatar() in a script, retain its UUID here, to reattach it later 
+	LLUUID sAssetToReattach;
+	int sTimeBeforeReattaching;
+
+private:
+	std::string sParcelName; // for convenience (gAgent does not retain the name of the current parcel)
+	BOOL sInventoryFetched; // FALSE at first, used to fetch RL Share inventory once upon login
+	BOOL sAllowCancelTp; // TRUE unless forced to TP with @tpto (=> receive TP order from server, act like it is a lure from a Linden => don't show the cancel button)
+	LLUUID sSitTargetId;
+	std::string sLastLoadedPreset; // contains the name of the latest loaded Windlight preset
+};
+
+
+#endif
